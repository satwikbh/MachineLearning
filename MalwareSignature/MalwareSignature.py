import urllib

from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient
from time import time

from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Utils.LoggerUtil import LoggerUtil


class MalwareSignature:
    """
    This class works on the backend. It takes a cluster and for each malware in the cluster,
    finds the features and then builds a frequency for the features.
    Then based on the pruning parameter picked from configuration, the values occurring less than it are removed.
    From the remaining values, the malware signature for the cluster are generated using CreateYaraRules class.
    An executable is scanned using MalwareScanner class.
    """

    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.db_utils = DBUtils()
        self.parser = ParsingLogic()
        self.helper = HelperFunction()
        self.config = ConfigUtil().get_config_instance()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        signatures_db_name = self.config['environment']['mongo']['signatures_db_name']
        signatures_db = local_client[signatures_db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]
        collection_names = clusters_db.collection_names()

        return remote_client, local_client, clusters_db, signatures_db, collection_names, c2db_collection

    def generate_signatures(self, meta_list):
        """
        Takes the inverted frequency and from its top "K" values, generates YARA signatures.
        :param meta_list:
        :return:
        """
        signature_dict = dict()
        return signature_dict

    def get_freq_dist(self, collection, list_of_keys):
        """
        For all malware in a cluster, get the frequency distribution of the features.
        From this distribution, we take the top "k" values and generate YARA signatures out of it.
        :param collection:
        :param list_of_keys:
        :return:
        """
        freq_dist = dict()
        inverted_freq_dist = dict()

        doc2bow = self.parser.parse_each_document(collection=collection, list_of_keys=list_of_keys)
        meta_list = self.helper.flatten_list(doc2bow.values())
        self.log.info("Parsing meta list for Signature generation\nSize of meta list : {}".format(len(meta_list)))
        for index, value in enumerate(meta_list):
            if index % 1000 == 0:
                self.log.info("Meta List Iteration : {}".format(index / 1000))
            if value in freq_dist:
                freq_dist[value] += 1
            else:
                freq_dist[value] = 1

        for key, value in freq_dist.items():
            if value in inverted_freq_dist:
                inverted_freq_dist[value].append(key)
            else:
                inverted_freq_dist[value] = [key]

        return inverted_freq_dist

    def get_keys_in_cluster(self, clusters_db, collection_names):
        self.log.info("Total number of clusters : {}".format(len(collection_names)))
        cluster_key_dict = dict()
        for collection_name in collection_names:
            collection = clusters_db[collection_name]
            cursor = collection.aggregate([{"$group": {"_id": "$key"}}])
            list_of_keys = self.helper.cursor_to_list(cursor, "_id")
            cluster_key_dict[collection_name] = list_of_keys
        return cluster_key_dict

    def prune_inv_freq_dist(self, inverted_freq_dist, n_features_for_sig_gen):
        pruning_threshold = sum(inverted_freq_dist.keys()) / n_features_for_sig_gen
        final_result = list()
        for count, features in inverted_freq_dist.items():
            if count > pruning_threshold:
                final_result.append(features)
        return self.helper.flatten_list(final_result)

    def main(self):
        start_time = time()
        n_features_for_sig_gen = self.config[""]

        remote_client, local_client, clusters_db, signatures_db, collection_names, c2db_collection = self.get_collection()
        cluster_key_dict = self.get_keys_in_cluster(clusters_db=clusters_db, collection_names=collection_names)

        for cluster_name, list_of_keys in cluster_key_dict.items():
            inverted_freq_dist = self.get_freq_dist(collection=c2db_collection, list_of_keys=list_of_keys)
            meta_list = self.prune_inv_freq_dist(inverted_freq_dist, n_features_for_sig_gen)
            signature_dict = self.generate_signatures(meta_list)
            signature_coll = signatures_db[cluster_name]
            signature_coll.insert({"cluster_name": cluster_name, "signature": signature_dict})

        self.log.info("Total time taken : {}".format(time() - start_time))

        remote_client.close()
        local_client.close()


if __name__ == "__main__":
    signature = MalwareSignature()
    signature.main()
