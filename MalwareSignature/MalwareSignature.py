import glob
import json
from collections import defaultdict
from time import time
from urllib.parse import quote

from HelperFunctions.HelperFunction import HelperFunction
from MalwareSignature.CreateYaraRules import CreateYaraRules
from PrepareData.ParsingLogic import ParsingLogic
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Utils.LoggerUtil import LoggerUtil


class MalwareSignature:
    """
    This class works on the backend. It takes a cluster and for each malware in the cluster,
    finds the features and then builds a frequency for the features.
    Then based on the pruning parameter picked from configuration, the values occurring less than it are removed.
    From the remaining values, the malware signature for the cluster are generated using CreateYaraRules class.
    An executable is scanned using MalwareScanner class.
    """

    def __init__(self, use_trie_pruning):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.db_utils = DBUtils()
        self.parser = ParsingLogic(use_trie_pruning=use_trie_pruning)
        self.helper = HelperFunction()
        self.config = ConfigUtil().get_config_instance()
        self.yara_rules = CreateYaraRules(use_trie_pruning=use_trie_pruning)

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                          is_auth_enabled=is_auth_enabled,
                                          username=username, password=password)

        signatures_db_name = self.config['environment']['mongo']['signatures_db_name']
        signatures_db = client[signatures_db_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = client[clusters_db_name]

        cuckoo_db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = client[cuckoo_db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        return client, clusters_db, signatures_db, c2db_collection

    def get_freq_dist(self, collection, list_of_keys):
        """
        For all malware in a cluster, get the frequency distribution of the features.
        From this distribution, we take the top "k" values and generate YARA signatures out of it.
        :param collection:
        :param list_of_keys:
        :return:
        """
        freq_dist = dict()
        inverted_freq_dist = dict()

        list_of_docs = self.helper.convert_to_vs_keys(list_of_keys)
        doc2bow = self.parser.parse_list_of_documents(collection=collection, list_of_docs=list_of_docs)
        meta_list = self.helper.flatten_list(doc2bow.values())
        self.log.info("Parsing meta list for Signature generation\nSize of meta list : {}".format(len(meta_list)))
        for index, value in enumerate(meta_list):
            if index % 1000 == 0:
                self.log.info("Meta List Iteration : {}".format(index / 1000))
            if value in freq_dist:
                freq_dist[value] += 1
            else:
                freq_dist[value] = 1

        for key, value in freq_dist.items():
            if value in inverted_freq_dist:
                inverted_freq_dist[value].append(key)
            else:
                inverted_freq_dist[value] = [key]

        return inverted_freq_dist

    def get_keys_in_cluster(self, clusters_db, collection_names):
        self.log.info("Total number of clusters : {}".format(len(collection_names)))
        cluster_key_dict = dict()
        for collection_name in collection_names:
            collection = clusters_db[collection_name]
            cursor = collection.aggregate([{"$group": {"_id": "$key"}}])
            list_of_keys = self.helper.cursor_to_list(cursor, "_id")
            cluster_key_dict[collection_name] = list_of_keys
        return cluster_key_dict

    def prune_inv_freq_dist(self, inverted_freq_dist, n_features_for_sig_gen):
        pruning_threshold = sum(inverted_freq_dist.keys()) / n_features_for_sig_gen
        final_result = list()
        for count, features in inverted_freq_dist.items():
            if count > pruning_threshold:
                final_result.append(features)
        return self.helper.flatten_list(final_result)

    @staticmethod
    def get_freq(doc2bow, threshold):
        freq_dict = defaultdict(list)
        freq_dict.default_factory = freq_dict.__len__
        for doc_values in doc2bow.values():
            for each in doc_values:
                freq_dict[each]

        ordered_freq_dict = dict()
        cut_off = threshold * len(freq_dict.keys())
        for key, value in freq_dict.items():
            if value > cut_off:
                ordered_freq_dict[key] = value

        return ordered_freq_dict.keys()

    @staticmethod
    def load_pools(freq_individual_pool_path):
        meta_pool = list()
        pool_list = glob.glob(freq_individual_pool_path + "/" + "*.json")
        for indi_pool in pool_list:
            pool = json.load(open(indi_pool))
            meta_pool += pool
        return meta_pool

    def core_logic(self, goodware_features, clusters_db, collection_name, c2db_collection, threshold,
                   freq_individual_pool_path):
        """
        This takes a cluster (which is a collection in the clusters_db) and build yara signature for the collection.
        The logic is to get the top frequent features, prune them using good_ware signatures and then out of the
        resultant features generate a yara signature.
        :return:
        """
        self.log.info("Creating signature for the cluster : {}".format(collection_name))
        cluster_collection = clusters_db[collection_name]
        cursor = cluster_collection.find({"md5": {"$exists": True}}, {"md5": 1})
        list_of_keys = self.helper.cursor_to_list(cursor, identifier="md5")

        meta_pool = self.load_pools(freq_individual_pool_path=freq_individual_pool_path)

        counter = 0
        chunk_size = 100
        doc2bow = defaultdict(list)
        while counter < len(list_of_keys):
            if counter + chunk_size < len(list_of_keys):
                p_keys = list_of_keys[counter: counter + chunk_size]
            else:
                p_keys = list_of_keys[counter:]
            list_of_docs = self.helper.convert_to_vs_keys(p_keys)
            p_doc2bow = self.parser.parse_list_of_documents(collection=c2db_collection, list_of_docs=list_of_docs)
            for key, value in p_doc2bow.items():
                val = [_ for _ in value if _ in meta_pool]
                doc2bow[key] = val
            counter += chunk_size

        top_k_values = self.get_freq(doc2bow, threshold)
        yara_signature = self.yara_rules.gen_yara_sig(top_k_values, collection_name)
        return yara_signature

    def main(self):
        start_time = time()
        threshold = self.config["yara"]["threshold"]
        freq_individual_pool_path = self.config["data"]["freq_individual_feature_pool_path"]

        client, clusters_db, signatures_db, c2db_collection = self.get_collection()
        goodware_features = []
        for collection_name in clusters_db.collection_names():
            yara_signature = self.core_logic(goodware_features=goodware_features,
                                             clusters_db=clusters_db,
                                             collection_name=collection_name,
                                             c2db_collection=c2db_collection,
                                             threshold=threshold,
                                             freq_individual_pool_path=freq_individual_pool_path)
            self.yara_rules.store_signature(signatures_db, collection_name, yara_signature)

        self.log.info("Total time taken : {}".format(time() - start_time))

        client.close()


if __name__ == "__main__":
    signature = MalwareSignature(use_trie_pruning=True)
    signature.main()
