import json
import urllib
import sys
import pandas as pd

from collections import defaultdict
from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient

from Clustering.KMeansImpl import KMeansImpl
from HelperFunctions.DataStats import DataStats
from HelperFunctions.DistributePoolingSet import DistributePoolingSet
from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Utils.LoggerUtil import LoggerUtil


class MalwareSimilarity:
    def __init__(self, use_trie_pruning):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.db_utils = DBUtils()
        self.parser = ParsingLogic(use_trie_pruning=use_trie_pruning)
        self.dis_pool = DistributePoolingSet()
        self.kmeans = KMeansImpl()
        self.helper = HelperFunction()
        self.config = ConfigUtil().get_config_instance()
        self.data_stats = DataStats(use_trie_pruning=use_trie_pruning)

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        collection_names = clusters_db.collection_names()
        return remote_client, local_client, clusters_db, collection_names, c2db_collection

    def get_families_data(self, collection, list_of_keys, config_param_chunk_size):
        classified_families = defaultdict(list)
        unclassified_families = defaultdict(list)

        count = 0
        iteration = 0
        while count < len(list_of_keys):
            try:
                self.log.info("Iteration : {}".format(iteration))
                if count + config_param_chunk_size < len(list_of_keys):
                    p_value = list_of_keys[count:count + config_param_chunk_size]
                else:
                    p_value = list_of_keys[count:]
                n_value = [key.split("_")[1] for key in p_value if "VirusShare_" in key]
                count += config_param_chunk_size
                local_cursor = collection.find({"md5": {"$in": n_value}})
                for index, each_value in enumerate(local_cursor):
                    family = each_value['avclass']['result']
                    val = "VirusShare_" + each_value['md5']
                    if "SINGLETON" in family:
                        unclassified_families[family].append(val)
                    else:
                        classified_families[family].append(val)
                iteration += 1
            except Exception as e:
                self.log.error("Error : {}".format(e))

        malware_families_path = self.config['data']['malware_families_list']

        json.dump(classified_families, open(malware_families_path + "/" + "classified_families.json", "w"))
        json.dump(unclassified_families, open(malware_families_path + "/" + "unclassified_families.json", "w"))

        self.log.info("Classified : {} \t Unclassified : {}".format(len(classified_families),
                                                                    len(unclassified_families)))
        l_value = classified_families.values()
        l_value = self.helper.is_nested_list(l_value)
        return l_value

    def split_into_sub_lists(self, bulk_list, avclass_collection, family_name):
        chunk_size = 10000
        count, local_iter = 0, 0
        success, failure = 0, 0
        while count < len(bulk_list):
            try:
                avclass_collection.insert_one({'family_name': family_name, 'feature_pool': [], "index": local_iter})
                if count + chunk_size < len(bulk_list):
                    values = bulk_list[count:count + chunk_size]
                else:
                    values = bulk_list[count:]
                avclass_collection.update_one({'family_name': family_name, 'index': local_iter},
                                              {'$push': {'feature_pool': values}})
                count += chunk_size
                success += 1
                local_iter += 1
            except Exception as e:
                failure += 1
                self.log.error("Error : {}".format(e))
        self.log.info("Success : {}\tFailure : {}".format(success, failure))

    def generate_feature_pool(self, c2db_collection, avclass_collection, list_of_keys, config_param_chunk_size,
                              family_name):
        count, iteration = 0, 0
        values = list()
        while count < len(list_of_keys):
            try:
                self.log.info("Iteration : {}".format(iteration))
                if count + config_param_chunk_size < len(list_of_keys):
                    value = list_of_keys[count:count + config_param_chunk_size]
                else:
                    value = list_of_keys[count:]
                count += config_param_chunk_size
                doc2bow = self.parser.parse_each_document(value, c2db_collection)
                values += self.helper.flatten_list(doc2bow.values())
                size = sys.getsizeof(values) * 1.0 / 10 ** 6
                self.log.info("Number of docs : {}\tSize of docs in MB : {}".format(len(values), size))
                iteration += 1
            except Exception as e:
                self.log.error("Error : {}".format(e))
        values = list(set(values))
        self.split_into_sub_lists(bulk_list=values,
                                  avclass_collection=avclass_collection,
                                  family_name=family_name)

    def get_malware_features(self, list_of_keys, collection, config_param_chunk_size):
        """
        This function will return the set of malware features.
        :param list_of_keys: List of malware md5's.
        :param collection:
        :return:
        """
        malware_features = defaultdict(list)
        count, iteration = 0, 0
        while count < len(list_of_keys):
            self.log.info("Iteration : {}".format(iteration))
            if count + config_param_chunk_size < len(list_of_keys):
                values = list_of_keys[count: count + config_param_chunk_size]
            else:
                values = list_of_keys[count:]
            doc2bow = self.parser.parse_each_document(values, collection)
            for key, value in doc2bow.items():
                malware_features[key] = list(set(value))
            del doc2bow
            iteration += 1
            count += config_param_chunk_size
        return malware_features

    def get_similarity_matrix(self, clusters_db, collection_names, malware_features_dict):
        """
        Takes a malware feature and compares it with each cluster's features.
        The result is a dict which has cluster name as the key and score are result.
        :param clusters_db:
        :param collection_names:
        :param malware_features_dict:
        :return:
        """
        similarity_dict = defaultdict(dict)
        for collection_name in collection_names:
            try:
                column_values = dict()
                collection = clusters_db[collection_name]
                cursor = collection.find({}, {"feature_pool": 1})
                doc_dict = defaultdict(set)
                doc_dict.default_factory = doc_dict.__len__

                for doc in cursor:
                    for x in self.helper.flatten_list(doc["feature_pool"]):
                        doc_dict[x]

                for malware_name, malware_features in malware_features_dict.items():
                    try:
                        numerator = len([x for x in malware_features if x in doc_dict])
                        denominator = len(malware_features) + len(doc_dict.keys()) - numerator
                        score = numerator * 1.0 / denominator
                        column_values[malware_name] = score
                    except Exception as e:
                        self.log.error("Error : {}\t Malware name : {}".format(e, malware_name))
                similarity_dict[collection_name] = column_values
            except Exception as e:
                self.log.error("Error : {}\tCollection Name : {}".format(e, collection_name))

        return similarity_dict

    def main(self, list_of_keys):
        self.log.info("Total malware : {}".format(len(list_of_keys)))

        remote_client, local_client, clusters_db, collection_names, c2db_collection = self.get_collection()
        config_param_chunk_size = self.config["data"]["config_param_chunk_size"]
        f_path = self.config["data"]["config_param_chunk_size"]
        final_result = list()

        count, iteration = 0, 0
        while count < len(list_of_keys):
            self.log.info("Malware Signature Iteration : {}".format(iteration))
            if count + config_param_chunk_size < len(list_of_keys):
                keys = list_of_keys[count:count + config_param_chunk_size]
            else:
                keys = list_of_keys[count:]

            malware_features = self.get_malware_features(list_of_keys=keys,
                                                         collection=c2db_collection,
                                                         config_param_chunk_size=config_param_chunk_size)
            similarity_dict = self.get_similarity_matrix(clusters_db, collection_names, malware_features)
            similarity_df = pd.DataFrame(similarity_dict)
            similarity_df.to_csv(f_path)
            final_result.append(similarity_df)
            del similarity_df
            count += config_param_chunk_size
            iteration += 1
        
        final_df = pd.concat([pd.read_csv(x) for x in final_result])
        self.log.info("Done")

        remote_client.close()
        local_client.close()

        return final_df, f_path


if __name__ == "__main__":
    similarity = MalwareSimilarity(use_trie_pruning=True)
    final_df, f_path = similarity.main(list_of_keys=[])
    final_df.to_csv(f_path)