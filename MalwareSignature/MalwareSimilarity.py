import json
import urllib
import sys
import pandas as pd

from collections import defaultdict
from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient

from Clustering.KMeansImpl import KMeansImpl
from HelperFunctions.DataStats import DataStats
from HelperFunctions.DistributePoolingSet import DistributePoolingSet
from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Utils.LoggerUtil import LoggerUtil


class MalwareSimilarity:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.db_utils = DBUtils()
        self.parser = ParsingLogic()
        self.dis_pool = DistributePoolingSet()
        self.kmeans = KMeansImpl()
        self.helper = HelperFunction()
        self.config = ConfigUtil().get_config_instance()
        self.data_stats = DataStats()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        collection_names = clusters_db.collection_names()
        return remote_client, local_client, clusters_db, collection_names, c2db_collection

    def get_families_data(self, collection, list_of_keys, config_param_chunk_size):
        classified_families = defaultdict(list)
        unclassified_families = defaultdict(list)

        count = 0
        iteration = 0
        while count < len(list_of_keys):
            try:
                self.log.info("Iteration : {}".format(iteration))
                if count + config_param_chunk_size < len(list_of_keys):
                    p_value = list_of_keys[count:count + config_param_chunk_size]
                else:
                    p_value = list_of_keys[count:]
                n_value = [key.split("_")[1] for key in p_value if "VirusShare_" in key]
                count += config_param_chunk_size
                local_cursor = collection.find({"md5": {"$in": n_value}})
                for index, each_value in enumerate(local_cursor):
                    family = each_value['avclass']['result']
                    val = "VirusShare_" + each_value['md5']
                    if "SINGLETON" in family:
                        unclassified_families[family].append(val)
                    else:
                        classified_families[family].append(val)
                iteration += 1
            except Exception as e:
                self.log.error("Error : {}".format(e))

        malware_families_path = self.config['data']['malware_families_list']

        json.dump(classified_families, open(malware_families_path + "/" + "classified_families.json", "w"))
        json.dump(unclassified_families, open(malware_families_path + "/" + "unclassified_families.json", "w"))

        self.log.info("Classified : {} \t Unclassified : {}".format(len(classified_families),
                                                                    len(unclassified_families)))
        l_value = classified_families.values()
        l_value = self.helper.is_nested_list(l_value)
        return l_value

    def split_into_sub_lists(self, bulk_list, avclass_collection, family_name):
        chunk_size = 10000
        count, local_iter = 0, 0
        success, failure = 0, 0
        while count < len(bulk_list):
            try:
                avclass_collection.insert_one({'family_name': family_name, 'feature_pool': [], "index": local_iter})
                if count + chunk_size < len(bulk_list):
                    values = bulk_list[count:count + chunk_size]
                else:
                    values = bulk_list[count:]
                avclass_collection.update_one({'family_name': family_name, 'index': local_iter},
                                              {'$push': {'feature_pool': values}})
                count += chunk_size
                success += 1
                local_iter += 1
            except Exception as e:
                failure += 1
                self.log.error("Error : {}".format(e))
        self.log.info("Success : {}\tFailure : {}".format(success, failure))

    def generate_feature_pool(self, c2db_collection, avclass_collection, list_of_keys, config_param_chunk_size,
                              family_name):
        count, iteration = 0, 0
        values = list()
        while count < len(list_of_keys):
            try:
                self.log.info("Iteration : {}".format(iteration))
                if count + config_param_chunk_size < len(list_of_keys):
                    value = list_of_keys[count:count + config_param_chunk_size]
                else:
                    value = list_of_keys[count:]
                count += config_param_chunk_size
                doc2bow = self.parser.parse_each_document(value, c2db_collection)
                values += self.helper.flatten_list(doc2bow.values())
                size = sys.getsizeof(values) * 1.0 / 10 ** 6
                self.log.info("Number of docs : {}\tSize of docs in MB : {}".format(len(values), size))
                iteration += 1
            except Exception as e:
                self.log.error("Error : {}".format(e))
        values = list(set(values))
        self.split_into_sub_lists(bulk_list=values,
                                  avclass_collection=avclass_collection,
                                  family_name=family_name)

    def get_malware_features(self, list_of_keys, collection):
        """
        This function will return the set of malware features.
        :param list_of_keys: List of malware md5's.
        :param collection:
        :return:
        """
        malware_features = defaultdict(list)
        for each_malware in list_of_keys:
            self.log.info("Working on malware with md5 : {}".format(each_malware))
            doc2bow = self.parser.parse_each_document(each_malware, collection)
            malware_features[each_malware] = list(set(doc2bow.values()))
            del doc2bow
        return malware_features

    def get_similarity_matrix(self, clusters_db, collection_names, malware_features_dict):
        """
        Takes a malware feature and compares it with each cluster's features.
        The result is a dict which has cluster name as the key and score are result.
        :param clusters_db:
        :param collection_names:
        :param malware_features_dict:
        :return:
        """
        similarity_dict = defaultdict(dict)
        for malware_name, malware_features in malware_features_dict.items():
            cluster_cols = dict()
            for collection_name in collection_names:
                collection = clusters_db[collection_name]
                cursor = collection.find({}, {"feature_pool": 1})
                values = set()
                for doc in cursor:
                    values = set.union(*[values, set(self.helper.flatten_list(doc["feature_pool"]))])
                numerator = len(set.intersection(*[values, malware_features]))
                denominator = len(set.union(*[values, malware_features]))
                score = numerator * 1.0 / denominator
                cluster_cols[collection_name] = score
            similarity_dict[malware_name] = cluster_cols
        return similarity_dict

    def main(self, list_of_keys):
        self.log.info("Total malware : {}".format(len(list_of_keys)))

        remote_client, local_client, clusters_db, collection_names, c2db_collection = self.get_collection()

        malware_features = self.get_malware_features(list_of_keys=list_of_keys, collection=c2db_collection)
        similarity_dict = self.get_similarity_matrix(clusters_db, collection_names, malware_features)
        similarity_df = pd.DataFrame(similarity_dict)
        self.log.info("Similarity DataFrame : {}".format(similarity_df))

        remote_client.close()
        local_client.close()


if __name__ == "__main__":
    similarity = MalwareSimilarity()
    similarity.main(list_of_keys=[])
