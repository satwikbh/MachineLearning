import urllib

from time import time

from Utils.LoggerUtil import LoggerUtil
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Cluster2DB.CuckooQueue import CuckooQueue
from HelperFunctions.HelperFunction import HelperFunction


class MalwareScanner:
    """
    Use only for bulk scanning. If you want results for fewer malware, use Cosine Distance based method.
    For each executable in the bulk, this class performs
    1. Check if the executable is present in the existing database .
    2. If it doesn't exist, scan it using the signature database and return response.
    3. Response contains the class to which the malware belongs.
    4. Parallelly, if the executable is not present in the existing database, it is subjected to behavioral analysis.
    # Future Implementation :
    Support to check for "Benign" executables.
    """

    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.cuckoo_queue = CuckooQueue()
        self.helper = HelperFunction()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']

        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db, is_auth_enabled=is_auth_enabled,
                                          username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = client[db_name]

        signatures_db_name = self.config['environment']['mongo']['signatures_db_name']
        signatures_db = client[signatures_db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        avclass_collection_name = self.config['environment']['mongo']['avclass_collection_name']
        avclass_collection = cuckoo_db[avclass_collection_name]

        return client, signatures_db, c2db_collection, avclass_collection

    @staticmethod
    def check_if_aready_scanned(list_of_keys, c2db_collection):
        """
        Takes the list of keys submitted and checks if there are any which are already scanned.
        Returns the keys which are not scanned previously.
        :param list_of_keys:
        :param c2db_collection:
        :return:
        """
        cursor = c2db_collection.aggregate([{"$group": {"$in": list_of_keys}}])
        list_of_keys = set(list_of_keys)
        new_list_of_keys = set()
        for doc in cursor:
            new_list_of_keys.add(doc["_id"])
        return list_of_keys.difference(new_list_of_keys)

    def scan_using_signature(self, avclass_collection, list_of_keys):
        """
        Scan the malware md5 list using the signatures and return response.
        The response consists of the family name to which the malware belongs.
        :param avclass_collection:
        :param list_of_keys:
        :return:
        """
        count = 0
        chunk = 1000
        result_list = list()
        while count < len(list_of_keys):
            if count + chunk > len(list_of_keys):
                temp_list = list_of_keys[count:]
            else:
                temp_list = list_of_keys[count: count + chunk]
            cursor = avclass_collection.find({"md5": {"$in": temp_list}}, {"md5": 1, "avclass.result": 1})
            count += chunk
            result_list += [x for x in cursor]
        if len(result_list) > 0 and isinstance(result_list[0], list):
            result_list = self.helper.flatten_list(result_list)
        return result_list

    @staticmethod
    def make_dict(list_of_keys, keys_path):
        key_path_dict = dict()
        for x in xrange(len(list_of_keys)):
            key_path_dict[list_of_keys[x]] = keys_path[x]
        return key_path_dict

    def main(self, list_of_keys, keys_path, flag=False):
        """
        The main method of Scanner which takes a list of malware md5 and their paths.
        If the malware is not scanned, it submits to the kafka queue the path and md5 value.
        If the malware is scanned, it will return the family to which it belongs.
        :param list_of_keys: list of md5 keys.
        :param keys_path: list of paths for the md5 executables.
        :param flag: The flag implies method local method invocation. Hence check in db.
        :return:
        """
        start_time = time()
        key_path_dict = self.make_dict(list_of_keys, keys_path)
        client, signatures_db, c2db_collection, avclass_collection = self.get_collection()

        if not flag:
            # The flag implies method local method invocation. Hence check in db.
            list_of_keys = list(self.check_if_aready_scanned(list_of_keys, c2db_collection))
            for x in xrange(len(list_of_keys)):
                md5_value = list_of_keys[x]
                self.cuckoo_queue.main(md5_value=md5_value, md5_path=key_path_dict[md5_value])

        list_of_keys = self.helper.convert_from_vs_keys(list_of_keys)
        result_list = self.scan_using_signature(avclass_collection, list_of_keys)
        self.log.info("Total time taken : {}".format(time() - start_time))

        client.close()

        return result_list


if __name__ == '__main__':
    scanner = MalwareScanner()
    result = scanner.main(list_of_keys=[], keys_path=[], flag=False)
