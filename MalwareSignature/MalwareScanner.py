import urllib

from pymongo import MongoClient
from sshtunnel import SSHTunnelForwarder
from time import time

from Utils.LoggerUtil import LoggerUtil
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Cluster2DB.CuckooQueue import CuckooQueue
from HelperFunctions.HelperFunction import HelperFunction


class MalwareScanner:
    """
    Use only for bulk scanning. If you want results for fewer malware, use Cosine Distance based method.
    For each executable in the bulk, this class performs
    1. Check if the executable is present in the existing database .
    2. If it doesn't exist, scan it using the signature database and return response.
    3. Response contains the class to which the malware belongs.
    4. Parallelly, if the executable is not present in the existing database, it is subjected to behavioral analysis.
    # Future Implementation :
    Support to check for "Benign" executables.
    """

    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.cuckoo_queue = CuckooQueue()
        self.helper = HelperFunction()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']

        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        signatures_db_name = self.config['environment']['mongo']['signatures_db_name']
        signatures_db = local_client[signatures_db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        avclass_collection_name = self.config['environment']['mongo']['avclass_collection_name']
        avclass_collection = cuckoo_db[avclass_collection_name]

        return remote_client, local_client, signatures_db, c2db_collection, avclass_collection

    @staticmethod
    def check_if_aready_scanned(list_of_keys, c2db_collection):
        """
        Takes the list of keys submitted and checks if there are any which are already scanned.
        Returns the keys which are not scanned previously.
        :param list_of_keys:
        :param c2db_collection:
        :return:
        """
        cursor = c2db_collection.aggregate([{"$group": {"$in": list_of_keys}}])
        list_of_keys = set(list_of_keys)
        new_list_of_keys = set()
        for doc in cursor:
            new_list_of_keys.add(doc["_id"])
        return list_of_keys.difference(new_list_of_keys)

    @staticmethod
    def scan_using_signature(avclass_collection, list_of_keys):
        """
        Scan the malware md5 list using the signatures and return response.
        The response consists of the family name to which the malware belongs.
        :param avclass_collection:
        :param list_of_keys:
        :return:
        """
        cursor = avclass_collection.find({"md5": {"$in": list_of_keys}}, {"md5": 1, "avclass.result": 1})
        result_list = [x for x in cursor]
        return result_list

    @staticmethod
    def make_dict(list_of_keys, keys_path):
        key_path_dict = dict()
        for x in xrange(len(list_of_keys)):
            key_path_dict[list_of_keys[x]] = keys_path[x]
        return key_path_dict

    def main(self, list_of_keys, keys_path):
        start_time = time()
        key_path_dict = self.make_dict(list_of_keys, keys_path)
        remote_client, local_client, signatures_db, c2db_collection, avclass_collection = self.get_collection()
        result_list = self.scan_using_signature(avclass_collection, list_of_keys)
        new_list_of_keys = list(self.check_if_aready_scanned(list_of_keys, c2db_collection))
        for x in xrange(len(new_list_of_keys)):
            md5_value = new_list_of_keys[x]
            self.cuckoo_queue.main(md5_value=md5_value, md5_path=key_path_dict[md5_value])
        self.log.info("Total time taken : {}".format(time() - start_time))

        remote_client.close()
        local_client.close()

        return result_list


if __name__ == '__main__':
    scanner = MalwareScanner()
    result = scanner.main(list_of_keys=[], keys_path=[])
