import yara
import json
import datetime
import urllib

from pymongo import MongoClient
from sshtunnel import SSHTunnelForwarder
from collections import defaultdict

from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from Utils.ConfigUtil import ConfigUtil
from PrepareData.ParsingLogic import ParsingLogic
from HelperFunctions.HelperFunction import HelperFunction


class CreateYaraRules:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.db_utils = DBUtils()
        self.config = ConfigUtil.get_config_instance()
        self.parser = ParsingLogic()
        self.helper = HelperFunction()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)

        signatures_db_name = self.config['environment']['mongo']['signatures_db_name']
        signatures_db = remote_client[signatures_db_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]
        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        return remote_client, local_client, clusters_db, signatures_db, c2db_collection

    def get_freq(self, doc2bow, threshold):
        freq_dict = defaultdict(list)
        freq_dict.default_factory = freq_dict.__len__
        for doc_values in doc2bow.values():
            for each in doc_values:
                freq_dict[each]

        ordered_freq_dict = dict()
        cut_off = threshold * len(freq_dict.keys())
        for key, value in freq_dict.items():
            if value > cut_off:
                ordered_freq_dict[key] = value

        return ordered_freq_dict.keys()

    @staticmethod
    def get_template(rule_name, author, description, string_values_list):
        """
        Takes the params and generates the template for the yara rule.
        See yara docs for more info on how to write and compile yara rules.
        :param rule_name:
        :param author:
        :param description:
        :param string_values_list:
        :return:
        """
        identifiers = ['fullword', 'wide', 'ascii']
        strings = ""
        conditions = ['all of them']
        for index, string_value in enumerate(string_values_list):
            if '\\' in string_value or '(' in string_value or ')' in string_value or '{' in string_value or '}' in string_value:
                tmp = str(string_value).encode('string_escape')
                strings += "$s" + str(index) + " = " + ' \"' + tmp + '\"' + " " + identifiers[0] + " " + \
                           identifiers[2] + "\n"
            else:
                strings += "$s" + str(index) + " = " + ' \"' + string_value + '\"' + " " + identifiers[0] + "\n"

        rule = "rule " + rule_name + " {" + "\n" + \
               "meta:" + "\n" + \
               "description = " + '\"' + description + '\"' + "\n" + \
               "author = " + '\"' + author + '\"' + "\n" + \
               "time = " + '\"' + str(datetime.datetime.now()) + '\"' + "\n" + \
               "strings: " + "\n" + strings + "\n" + \
               "condition:" + "\n" + conditions[0] + "\n" + \
               "}"

        return rule

    def gen_yara_sig(self, top_k_values, cluster_name):
        """
        Takes the frequent features for the family with cluster_name and return the compiled yara rule.
        :param top_k_values:
        :param cluster_name:
        :return:
        """
        try:
            author = self.config['yara']['author']
            description = 'Auto-generated rule for family : ' + cluster_name
            signature = self.get_template(rule_name=cluster_name,
                                          author=author,
                                          description=description,
                                          string_values_list=top_k_values)
            rule_path = self.config['yara']['rule_path'] + cluster_name + ".yara"
            f = open(rule_path, 'w')
            print >> f, signature
            f.close()
            # If there is a error below then it is not a proper yara rule.
            yara.compile(filepath=rule_path)
            return signature
        except Exception as e:
            self.log.error("Error : {}".format(e))

    def core_logic(self, goodware_features, clusters_db, collection_name, c2db_collection, threshold):
        """
        This takes a cluster (which is a collection in the clusters_db) and build yara signature for the collection.
        The logic is to get the top frequent features, prune them using good_ware signatures and then out of the
        resultant features generate a yara signature.
        :return:
        """
        self.log.info("Creating signature for the cluster : {}".format(collection_name))
        cluster_collection = clusters_db[collection_name]
        cursor = cluster_collection.find({"md5": {"$exists": True}}, {"md5": 1})
        list_of_keys = self.helper.cursor_to_list(cursor, identifier="md5")
        list_of_keys = self.helper.flatten_list(list_of_keys)
        list_of_keys = self.helper.convert_to_vs_keys(list_of_keys)
        doc2bow = self.parser.parse_each_document(collection=c2db_collection, list_of_docs=list_of_keys)
        top_k_values = self.get_freq(doc2bow, threshold)
        signature = self.gen_yara_sig(top_k_values, collection_name)
        return signature

    def store_signature(self, signatures_db, collection_name, signature):
        """
        Takes the signature and stores it in the signature_db with the same name as the clusters collection.
        :param signatures_db:
        :param collection_name:
        :param signature:
        :return:
        """
        try:
            if collection_name not in signatures_db.collection_names():
                signatures_db.create_collection(collection_name)
            collection = signatures_db[collection_name]
            signature_json = json.dumps(signature)
            collection.insert_one(signature_json)
        except Exception as e:
            self.log.error("Error : {}".format(e))

    def main(self):
        threshold = self.config["yara"]["threshold"]
        remote_client, local_client, clusters_db, signatures_db, c2db_collection = self.get_collection()
        goodware_features = []
        for collection_name in clusters_db.collection_names():
            yara_signature = self.core_logic(goodware_features=goodware_features,
                                             clusters_db=clusters_db,
                                             collection_name=collection_name,
                                             c2db_collection=c2db_collection,
                                             threshold=threshold)
            self.store_signature(signatures_db, collection_name, yara_signature)

        remote_client.close()
        local_client.close()


if __name__ == '__main__':
    yara_rules = CreateYaraRules()
    yara_rules.main()
