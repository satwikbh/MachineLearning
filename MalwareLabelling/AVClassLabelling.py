import urllib
from time import time

from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from Utils.ConfigUtil import ConfigUtil


class AVClassLabelling:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.db_utils = DBUtils()
        self.config = ConfigUtil().get_config_instance()

    def get_connection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db, is_auth_enabled=is_auth_enabled,
                                          username=username, password=password)

        db_name = self.config['environment']['mongo']['db_name']
        vt_collection_name = self.config['environment']['mongo']['virus_total_collection_name']
        avclass_collection_name = self.config['environment']['mongo']['avclass_collection_name']

        db = client[db_name]
        vt_collection = db[vt_collection_name]
        avclass_collection = db[avclass_collection_name]
        return client, vt_collection, avclass_collection

    def parse(self, scans):
        av_labels = list()
        for key, value in scans.items():
            av_labels.append([key, value["result"]])
        return av_labels

    @staticmethod
    def is_key_present_in_dict(key, dictionary):
        return key in dictionary

    def infer_av_label(self, cursor, collection):
        success_count = 0
        failure_count = 0
        documents = list()
        for cursor_next in cursor:
            try:
                result_dict = dict()
                if self.is_key_present_in_dict("sha1", cursor_next):
                    sha1 = cursor_next["sha1"]
                    result_dict["sha1"] = sha1
                if self.is_key_present_in_dict("scan_date", cursor_next):
                    scan_date = cursor_next["scan_date"]
                    result_dict["scan_date"] = scan_date
                if self.is_key_present_in_dict("first_seen", cursor_next):
                    first_seen = cursor_next["first_seen"]
                    result_dict["first_seen"] = first_seen
                if self.is_key_present_in_dict("sha256", cursor_next):
                    sha256 = cursor_next["sha256"]
                    result_dict["sha256"] = sha256
                if self.is_key_present_in_dict("md5", cursor_next):
                    md5 = cursor_next["md5"]
                    result_dict["md5"] = md5
                if self.is_key_present_in_dict("scans", cursor_next):
                    scans = cursor_next["scans"]
                    av_labels = self.parse(scans)
                    result_dict["av_labels"] = av_labels
                documents.append(result_dict)
                success_count += 1
            except Exception as e:
                self.log.error("Error : {}".format(e))
                failure_count += 1
        collection.insert_many(documents)
        return success_count, failure_count

    def prepare_data(self, collection):
        list_of_keys_cursor = collection.aggregate([{"$group": {"_id": "$malware_source"}}])
        list_of_keys = list()
        total_success_count, total_failure_count = 0, 0

        for each in list_of_keys_cursor:
            list_of_keys.append(each["_id"])

        self.log.info("Total number of variants : {}".format(len(list_of_keys)))

        count, iteration = 0, 0
        flag = True
        while flag:
            if count + 1000 < len(list_of_keys):
                partial_list = list_of_keys[count: count + 1000]
            else:
                partial_list = list_of_keys[count:]
                flag = False
            cursor = collection.find({"malware_source": {"$in": partial_list}})
            success_count, failure_count = self.infer_av_label(cursor, collection)
            total_success_count += success_count
            total_failure_count += failure_count
            iteration += 1
            count += 1000
            self.log.info("Iteration #{}".format(iteration))
        return total_success_count, total_failure_count

    def main(self):
        start_time = time()
        client, vt_collection, avclass_collection = self.get_connection()
        total_success_count, total_failure_count = self.prepare_data(vt_collection)
        self.log.info("Total Success : {}\tTotal Failure : {}".format(total_success_count, total_failure_count))
        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    avclass = AVClassLabelling()
    avclass.main()
