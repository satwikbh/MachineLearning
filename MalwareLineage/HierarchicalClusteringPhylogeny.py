import numpy as np
import matplotlib
import json

from collections import defaultdict
from time import time
from urllib.parse import quote
from json import load
from numpy import asarray
from matplotlib.pyplot import figure
from sys import setrecursionlimit

from sklearn.metrics import pairwise_distances_chunked
from sklearn.cluster import AgglomerativeClustering
from scipy.sparse import load_npz, vstack, hstack
from scipy.cluster.hierarchy import dendrogram, linkage
from sklearn.metrics import pairwise_distances
from skbio.tree import TreeNode
from ete3 import Tree

from Utils.LoggerUtil import LoggerUtil
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from HelperFunctions.HelperFunction import HelperFunction

matplotlib.use('Agg')
setrecursionlimit(50000)


class HierarchicalClusteringPhylogeny:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.helper = HelperFunction()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                          is_auth_enabled=is_auth_enabled,
                                          username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = client[db_name]

        phylogeny_collection_name = self.config['environment']['mongo']['phylogeny_collection']
        phylogeny_collection = cuckoo_db[phylogeny_collection_name]

        return phylogeny_collection

    @staticmethod
    def load_fv(path):
        fv = []
        for x in range(3467):
            fv.append(load_npz(path + "/" + "feature_vector_part_" + str(x) + ".npz"))
        return vstack(fv)

    def get_dr_matrices(self, data_path):
        """
        Load the individual frequency based pruned data
        :param data_path:
        :return:
        """
        files_fv = self.load_fv(path=data_path + "/" + "files_fv")
        reg_keys_fv = self.load_fv(path=data_path + "/" + "reg_keys_fv/")
        mutexes_fv = self.load_fv(path=data_path + "/" + "mutexes_fv/")
        exec_cmds_fv = self.load_fv(path=data_path + "/" + "exec_cmds_fv/")
        network_fv = self.load_fv(path=data_path + "/" + "network_fv/")
        static_fv = self.load_fv(path=data_path + "/" + "static_fv/")

        data = hstack([files_fv, reg_keys_fv, mutexes_fv, exec_cmds_fv, network_fv, static_fv])
        del files_fv, reg_keys_fv, mutexes_fv, exec_cmds_fv, network_fv, static_fv

        self.log.info("Freq based Data (n_samples, n_features) : ({})".format(data.shape))
        return data

    @staticmethod
    def get_data_labels(data, list_of_keys, labels, index):
        bool_arr = labels == int(index)
        family_data = data[bool_arr]
        family_keys = list_of_keys[bool_arr]
        return family_data, family_keys

    @staticmethod
    def new_get_data_labels(data, list_of_keys, indices):
        return data[indices], list_of_keys[indices]

    @staticmethod
    def get_linkage_matrix(family_data):
        dist_matrix = pairwise_distances(
            family_data, metric="euclidean", n_jobs=10)
        z = linkage(dist_matrix, 'ward')
        return z

    def new_get_linkage_matrix(self, family_data):
        """
        TODO: This is a parallel distance matrix construction code.
        Remove this incase you're not using the dist. matrix to compute Dendrograms.
        """
        """
        dist_matrix = list()
        gen = pairwise_distances_chunked(
            family_data, n_jobs=20, metric='euclidean', working_memory=0)
        flag = True
        i = 0
        self.log.info(F"Shape of data : {family_data.shape}")
        while flag:
            try:
                if i % 1000 == 0:
                    self.log.info(F"Processed row : {i}")
                p_dist_matrix = next(gen)
                for j in range(p_dist_matrix.shape[1]):
                    if i < j:
                        dist_matrix.append(p_dist_matrix[0][j])
                i += 1
            except Exception as e:
                self.log.error(F"Error : {e}")
                flag = False
        dist_matrix = np.reshape(dist_matrix, (len(dist_matrix), 1))
        """
        dist_matrix = np.load("/home/satwik/Desktop/hidelink_dist_matrix.npz")['a']
        agg_clus = AgglomerativeClustering(dist_matrix)
        z = linkage(agg_clus.n_clusters, 'ward')
        return z

    @staticmethod
    def build_ete_tree(linkage_matrix, list_of_keys):
        t = TreeNode.from_linkage_matrix(linkage_matrix, id_list=list_of_keys)
        tree = Tree.from_skbio(t)
        return tree

    def store_lineage_results(self, family_node_dict, phylogeny_collection):
        for md5_value, node_dict in family_node_dict.items():
            try:
                document = dict()
                document["vs_md5"] = md5_value
                document["sisters"] = node_dict["sisters"]
                document["children"] = node_dict["children"]
                phylogeny_collection.insert_one(document)
            except Exception as e:
                self.log.error("Error : {}".format(e))

    def get_all_children(self, node):
        leaf_list = []
        if node.is_leaf():
            leaf_list.append(node.name)
        else:
            children = node.get_children()
            for each in children:
                leaf_list += self.get_all_children(each)
        return leaf_list

    def get_family_node_dict(self, tree, family_keys):
        meta_node_dict = defaultdict()
        for vs_md5 in family_keys:
            node_dict = dict()
            try:
                children_nodes_list = list()
                sister_nodes_list = list()
                target_node = tree.search_nodes(name=vs_md5)[0]
                children_nodes = target_node.get_children()
                if len(children_nodes) != 0:
                    for child_node in children_nodes:
                        children_nodes_list += self.get_all_children(
                            child_node)
                sister_nodes = target_node.get_sisters()
                if len(sister_nodes) != 0:
                    for node in sister_nodes:
                        sister_nodes_list += self.get_all_children(node)
                node_dict['children'] = children_nodes_list
                node_dict['sisters'] = sister_nodes_list
            except Exception as e:
                self.log.error("Error : {} \nKey : {}".format(e, vs_md5))
            meta_node_dict[vs_md5] = node_dict
        return meta_node_dict

    @staticmethod
    def plot_figure(linkage_matrix, fig_path, family_name):
        fig = figure(figsize=(25, 10))
        dendrogram(linkage_matrix)
        tree_fname = fig_path + "/" + str(family_name) + ".png"
        fig.savefig(tree_fname)

    def core_method(self, family_data, family_keys, phylogeny_collection, fig_path, family_name):
        if family_data.shape[0] > 30000:
            linkage_matrix = self.new_get_linkage_matrix(family_data)
        else:
            linkage_matrix = self.get_linkage_matrix(family_data)
        tree = self.build_ete_tree(
            linkage_matrix=linkage_matrix, list_of_keys=family_keys)
        family_node_dict = self.get_family_node_dict(tree, family_keys)
        self.store_lineage_results(family_node_dict, phylogeny_collection)
        self.plot_figure(linkage_matrix, fig_path, family_name)

    def main(self):
        start_time = time()

        phylo_path = self.config["environment"]["phylogenetic_clustering"]
        labels_path = self.config["data"]["labels_path"]
        data_path = self.config["data"]["freq_individual_feature_pool"]
        fig_path = self.config["data"]["phylogeny_results"]

        labels = asarray(load(open(labels_path + "/" + "labels.json")))
        list_of_keys = asarray(
            load(open(labels_path + "/" + "list_of_keys.json")))
        fam_label = load(
            open(labels_path + "/" + "family_index_label_dict.json"))

        phylogeny_collection = self.get_collection()

        self.helper.create_dir_if_absent(phylo_path)
        data = self.get_dr_matrices(data_path=data_path).toarray()
        # mlp_preds = json.load(open("/home/satwik/Documents/MachineLearning/DataMain/Results/ClassificationResults/MLP/MLPPredictions.json"))

        for index, name in fam_label.items():
        # for keys, values in mlp_preds.items():
            # name = fam_label[keys]
            self.log.info("Working on family : {}".format(name))
            # family_data, family_keys = self.new_get_data_labels(data, list_of_keys, indices=values)
            family_data, family_keys = self.get_data_labels(data, list_of_keys, labels, index)
            self.core_method(family_data=family_data, family_keys=family_keys,
                             phylogeny_collection=phylogeny_collection,
                             fig_path=fig_path, family_name=name)

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    hcp = HierarchicalClusteringPhylogeny()
    hcp.main()
