import pickle as pi
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import json

from collections import defaultdict
from time import time
from urllib.parse import quote

from scipy.sparse import load_npz, vstack, hstack
from scipy.cluster.hierarchy import dendrogram, linkage
from sklearn.metrics import pairwise_distances
from skbio.tree import TreeNode
from ete3 import Tree

from Utils.LoggerUtil import LoggerUtil
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from HelperFunctions.HelperFunction import HelperFunction

matplotlib.use('Agg')


class HierarchicalClusteringPhylogeny:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.helper = HelperFunction()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                          is_auth_enabled=is_auth_enabled,
                                          username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = client[db_name]

        phylogeny_collection_name = self.config['environment']['mongo']['phylogeny_collection']
        phylogeny_collection = cuckoo_db[phylogeny_collection_name]

        return phylogeny_collection

    @staticmethod
    def load_fv(path):
        fv = []
        for x in range(3467):
            fv.append(load_npz(path + "/" + "feature_vector_part_" + str(x) + ".npz"))
        return vstack(fv)

    def get_dr_matrices(self, data_path):
        """
        Load the individual frequency based pruned data
        :param data_path:
        :return:
        """
        files_fv = self.load_fv(path=data_path + "/" + "files_fv")
        reg_keys_fv = self.load_fv(path=data_path + "/" + "reg_keys_fv/")
        mutexes_fv = self.load_fv(path=data_path + "/" + "mutexes_fv/")
        exec_cmds_fv = self.load_fv(path=data_path + "/" + "exec_cmds_fv/")
        network_fv = self.load_fv(path=data_path + "/" + "network_fv/")
        static_fv = self.load_fv(path=data_path + "/" + "static_fv/")

        data = hstack([files_fv, reg_keys_fv, mutexes_fv, exec_cmds_fv, network_fv, static_fv])
        del files_fv, reg_keys_fv, mutexes_fv, exec_cmds_fv, network_fv, static_fv

        self.log.info("Freq based Data (n_samples, n_features) : ({})".format(data.shape))
        return data

    @staticmethod
    def get_data_labels(data, list_of_keys, labels, index):
        bool_arr = labels == int(index)
        family_data = data.toarray()[bool_arr]
        family_keys = list_of_keys[bool_arr]
        return family_data, family_keys

    @staticmethod
    def get_linkage_matrix(family_data):
        dist_matrix = pairwise_distances(family_data, metric="euclidean", n_jobs=10)
        z = linkage(dist_matrix, 'ward')
        return z

    @staticmethod
    def build_ete_tree(linkage_matrix, list_of_keys):
        t = TreeNode.from_linkage_matrix(linkage_matrix, id_list=list_of_keys)
        tree = Tree.from_skbio(t)
        return tree

    def store_lineage_results(self, family_node_dict, phylogeny_collection):
        for md5_value, node_dict in family_node_dict.items():
            try:
                document = dict()
                document["vs_md5"] = md5_value
                document["sisters"] = node_dict["sisters"]
                document["children"] = node_dict["children"]
                phylogeny_collection.insert_one(document)
            except Exception as e:
                self.log.error("Error : {}".format(e))

    def get_all_children(self, node):
        leaf_list = []
        if node.is_leaf():
            leaf_list.append(node.name)
        else:
            children = node.get_children()
            for each in children:
                leaf_list += self.get_all_children(each)
        return leaf_list

    def family_node_dict(self, tree, family_keys):
        meta_node_dict = defaultdict()
        for vs_md5 in family_keys:
            node_dict = dict()
            try:
                children_nodes_list = list()
                sister_nodes_list = list()
                target_node = tree.search_nodes(name=vs_md5)[0]
                children_nodes = target_node.get_children()
                if len(children_nodes) != 0:
                    for child_node in children_nodes:
                        children_nodes_list += self.get_all_children(child_node)
                sister_nodes = target_node.get_sisters()
                if len(sister_nodes) != 0:
                    for node in sister_nodes:
                        sister_nodes_list += self.get_all_children(node)
                node_dict['children'] = children_nodes_list
                node_dict['sisters'] = sister_nodes_list
            except Exception as e:
                self.log.error("Error : {}".format(e))
            meta_node_dict[vs_md5] = node_dict
        return meta_node_dict

    @staticmethod
    def plot_figure(linkage_matrix, fig_path, family_name):
        fig = plt.figure(figsize=(25, 10))
        dendrogram(linkage_matrix)
        tree_fname = fig_path + "/" + str(family_name) + ".png"
        fig.savefig(tree_fname)

    def core_method(self, family_data, family_keys, phylogeny_collection, fig_path, family_name):
        linkage_matrix = self.get_linkage_matrix(family_data)
        tree = self.build_ete_tree(linkage_matrix=linkage_matrix, list_of_keys=family_keys)
        family_node_dict = self.family_node_dict(tree, family_keys)
        self.store_lineage_results(family_node_dict, phylogeny_collection)
        self.plot_figure(linkage_matrix, fig_path, family_name)

    def main(self, family_name, entire_data=False):
        start_time = time()

        phylo_path = self.config["environment"]["phylogenetic_clustering"]
        labels_path = self.config["data"]["labels_path"]
        data_path = self.config["data"]["freq_individual_feature_pool"]
        fig_path = self.config["data"]["phylogeny_results"]

        labels = np.asarray(pi.load(open(labels_path + "/" + "labels.pkl")))
        list_of_keys = np.asarray(pi.load(labels_path + "/" + "list_of_keys.pkl"))
        fam_label = json.load(open(labels_path + "/" + "family_index_label_dict.json"))

        phylogeny_collection = self.get_collection()

        self.helper.create_dir_if_absent(phylo_path)
        data = self.get_dr_matrices(data_path=data_path)

        for index, name in fam_label.items():
            self.log.info("Working on family : {}".format(name))
            if entire_data is False:
                if name == family_name:
                    family_data, family_keys = self.get_data_labels(data, list_of_keys, labels, index)
                else:
                    family_data, family_keys = None, None
            else:
                family_data, family_keys = self.get_data_labels(data, list_of_keys, labels, index)
            assert family_data is not None and family_keys is not None
            self.core_method(family_data=family_data, family_keys=family_keys,
                             phylogeny_collection=phylogeny_collection,
                             fig_path=fig_path, family_name=name)

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    hcp = HierarchicalClusteringPhylogeny()
    hcp.main(entire_data=False, family_name="")
