import matplotlib
import matplotlib.pyplot as plt
import urllib
import numpy as np

from scipy.sparse import coo_matrix, vstack
from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient
from collections import defaultdict
from time import time
from Bio import Phylo
from Bio.Align.Applications import ClustalwCommandline
from Bio import AlignIO

from Utils.ConfigUtil import ConfigUtil
from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from MalwareSignature.MalwareScanner import MalwareScanner
from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Cluster2DB.CuckooQueue import CuckooQueue


class LineageAnalysis:
    def __init__(self):
        self.log = LoggerUtil.get(self.__class__.__name__)
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.scanner = MalwareScanner()
        self.helper = HelperFunction()
        self.parser = ParsingLogic()
        self.cuckoo_queue = CuckooQueue()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        return remote_client, local_client, clusters_db, c2db_collection

    def sequence_alignment(self, doc2bow, md5_value):
        """
        Takes as input the doc2bow and then builds a meta_cluster.
        For each of the malware's features, it then creates a binary vector representation.
        The resultant output is the sequence in a coo_matrix format and row_index of the given malware.
        :param md5_value:
        :param doc2bow:
        :return:
        """
        meta_cluster_dict = defaultdict(list)
        meta_cluster_dict.default_factory = meta_cluster_dict.__len__

        meta_cluster = self.helper.flatten_list(doc2bow.values())
        for value in meta_cluster:
            meta_cluster_dict[value]

        meta_sequence = list()
        key_list = doc2bow.keys()
        for key, value in doc2bow.items():
            if key == md5_value:
                index = len(meta_sequence)
            column = [meta_cluster_dict[x] for x in value]
            row = len(column) * [0]
            data = len(column) * [1]
            value = coo_matrix((data, (row, column)), shape=(1, len(meta_cluster_dict.keys())), dtype=np.float32)
            meta_sequence.append(value)

        seq_matrix_repr = vstack(meta_sequence)
        seq_matrix_repr = seq_matrix_repr.tocsr()
        return seq_matrix_repr, index, key_list

    @staticmethod
    def plot_tree(tree, output_file, index):
        """
        Takes the newick tree data and then plots the dendrogram out of it.
        Saved the plot at the output location.
        :param tree:
        :param output_file:
        :param index:
        :return:
        """
        # TODO : Highlight the node at the index position so as to know that it is the malware scanned.
        matplotlib.rc('font', size=6)
        fig = plt.figure(figsize=(10, 20), dpi=100)
        axes = fig.add_subplot(1, 1, 1)
        plt.savefig(output_file, dpi=100)
        Phylo.draw(tree, axes=axes)
        return

    def build_phylogeny_tree(self, phylo_path, fasta_fname, index):
        """
        Takes the fasta file path as input and then generates the phylogenetic tree.
        :param phylo_path:
        :param fasta_fname:
        :param index:
        :return:
        """
        self.log.info("Building phylogenetic tree")
        align_fname = fasta_fname.split(".")[0] + ".aln"
        tree_fname = fasta_fname.split(".")[0] + ".dnd"
        tree_plot_path = phylo_path + "/" + fasta_fname.split(".")[0] + ".png"

        self.log.info("Invoking ClustalOmega as sub-process")
        cline = ClustalwCommandline("clustalw2", infile=fasta_fname)
        self.log.info("ClustalOmega params : {}".format(cline.parameters))

        align = AlignIO.read(align_fname, "clustal")

        self.log.info("Saving the tree plot at : {}".format(tree_plot_path))
        tree = Phylo.read(tree_fname, "newick")
        self.plot_tree(tree=tree, output_file=tree_plot_path, index=index)

    def phylogenetic_analysis(self, md5_value, clusters_db, c2db_collection, phylo_path):
        result = self.scanner.main(list_of_keys=[md5_value])
        family = result["family"]
        if family in clusters_db.collection_names():
            collection = clusters_db[family]
            cursor = collection.find({"md5": {"$exists": True}})
            list_of_keys = list()
            for doc in cursor:
                list_of_keys += doc["md5"]
            doc2bow = self.parser.parse_each_document(collection=c2db_collection, list_of_keys=list_of_keys)
            seq_matrix_repr, index, key_list = self.sequence_alignment(doc2bow, md5_value)
            fasta_fname = phylo_path + "/" + str(md5_value) + ".fasta"
            f = open(fasta_fname, "w")
            for x in xrange(seq_matrix_repr.shape[0]):
                print >> f, ">", key_list[x], "\n", "".join(map(str, seq_matrix_repr[x].A))
            f.close()
            self.build_phylogeny_tree(phylo_path, fasta_fname, index)
        else:
            self.log.error("The inferred family is not in the Database")

    @staticmethod
    def check_if_aready_scanned(md5_value, c2db_collection):
        key = "VirusShare_" + md5_value
        cursor = c2db_collection.find({"md5": key})
        if cursor.count() > 0:
            return True
        else:
            return False

    def main(self, md5_value, md5_path):
        start_time = time()
        phylo_path = self.config["environment"]["phylogenetic"]
        self.helper.create_dir_if_absent(phylo_path)
        remote_client, local_client, clusters_db, c2db_collection = self.get_collection()
        status = self.check_if_aready_scanned(md5_value, c2db_collection)
        if status:
            self.phylogenetic_analysis(md5_value, clusters_db, c2db_collection, phylo_path)
        else:
            self.log.info("The malware is not yet encountered.\nPlease wait while analysis is done on it.")
            self.cuckoo_queue.main(md5_value=md5_value, md5_path=md5_path)
        remote_client.close()
        local_client.close()

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    phylogeny = LineageAnalysis()
    phylogeny.main(md5_value="", md5_path="")
