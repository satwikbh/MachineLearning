import os
import urllib
import numpy as np
import matplotlib

from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient
from collections import defaultdict
from time import time
from ete3 import Tree
from subprocess import Popen

from Utils.ConfigUtil import ConfigUtil
from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from MalwareSignature.MalwareScanner import MalwareScanner
from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Cluster2DB.CuckooQueue import CuckooQueue
from HelperFunctions.Encoding import Encoding

matplotlib.use('Agg')


class PhylogeneticAnalysis:
    def __init__(self, log):
        self.log = log

        self.parser = ParsingLogic()
        self.encoder = Encoding()
        self.helper = HelperFunction()

    @staticmethod
    def remove_scanning_key(md5_value_list, doc2bow):
        doc2bow_test = defaultdict(list)
        for md5_value in md5_value_list:
            doc2bow_test[md5_value] = doc2bow[md5_value]
            doc2bow.pop(md5_value)
        return doc2bow_test, doc2bow

    def phylogenetic_analysis(self, **kwargs):
        """
        Separate this method
        :param kwargs:
        :return:
        """
        clusters_db = kwargs['clusters_db']
        c2db_collection = kwargs['c2db_collection']
        family = kwargs['family']
        phylo_path = kwargs['phylo_path']
        iterative = kwargs['iterative']
        encoding_method = kwargs['encoding_method']

        if family in clusters_db.collection_names():
            collection = clusters_db[family]
            cursor = collection.find({"md5": {"$exists": True}})
            list_of_keys = list()
            for doc in cursor:
                list_of_keys += doc["md5"]
            list_of_docs = self.helper.convert_to_vs_keys(list_of_keys)
            doc2bow = self.parser.parse_each_document(collection=c2db_collection, list_of_docs=list_of_docs)
            if iterative:
                present_list = kwargs['present_list']
                doc2bow_test, doc2bow = self.remove_scanning_key(present_list, doc2bow)
                sequence_list, key_list, meta_cluster_dict_len, meta_cluster_count_dict = self.sequence_alignment(
                    doc2bow, doc2bow_test)
                meta_sequence, test_sequence = sequence_list[0], sequence_list[1]
                fasta_file_name = self.add_sequence(phylo_path=phylo_path, encoding_method=encoding_method,
                                                    meta_cluster_count_dict=meta_cluster_count_dict,
                                                    meta_cluster_dict_len=meta_cluster_dict_len,
                                                    meta_sequence=meta_sequence, key_list=key_list,
                                                    iterative=iterative, present_list=doc2bow_test.keys(),
                                                    family=family, test_sequence=test_sequence)
            else:
                md5_value = kwargs['md5_value']
                doc2bow_test, doc2bow = self.remove_scanning_key([md5_value], doc2bow)
                sequence_list, key_list, meta_cluster_dict_len, meta_cluster_count_dict = self.sequence_alignment(
                    doc2bow, doc2bow_test)
                meta_sequence, test_sequence = sequence_list[0], sequence_list[1]
                fasta_file_name = self.add_sequence(phylo_path=phylo_path, encoding_method=encoding_method,
                                                    meta_cluster_count_dict=meta_cluster_count_dict,
                                                    meta_cluster_dict_len=meta_cluster_dict_len,
                                                    meta_sequence=meta_sequence, key_list=key_list,
                                                    iterative=iterative, md5_value=[md5_value],
                                                    family=family, test_sequence=test_sequence)
        else:
            self.log.error("The inferred family is not in the Database")
            fasta_file_name = None
        return fasta_file_name

    def get_all_children(self, node, leaf_list):
        if node.is_leaf():
            leaf_list.append(node.name)
        else:
            children = node.get_children()
            for each in children:
                self.get_all_children(each, leaf_list)

    def get_sister_groups(self, tree_fname, num_sim_malware_retrieve, md5_value):
        """
        Takes the tree and loads into ete3 Tree class. Finds the target position in the Phylo tree.
        Retrieves its sister groups, children if they are present.
        :param tree_fname:
        :param num_sim_malware_retrieve: Will be added in future.
        :param md5_value:
        :return:
        """
        node_dict = dict()
        children_nodes_list = list()
        sister_nodes_list = list()
        try:
            f = open(tree_fname, "r")
            tree = Tree(f.read())
            target_node = tree.search_nodes(name=md5_value)[0]
            children_nodes = target_node.get_children()
            if len(children_nodes) != 0:
                for child_node in children_nodes:
                    children_nodes_list += self.get_all_children(child_node, [])

            sister_nodes = target_node.get_sisters()
            if len(sister_nodes) != 0:
                for node in sister_nodes:
                    sister_nodes_list += self.get_all_children(node, [])

            node_dict['children'] = children_nodes_list
            node_dict['sisters'] = sister_nodes_list
            return node_dict
        except Exception as e:
            self.log.error("Error : {}".format(e))

    def build_phylogeny_tree(self, fasta_fname, iterative, k_sim_malware_retrieve, md5_value):
        """
        Takes the fasta file path as input and then generates the phylogenetic tree.
        :param fasta_fname:
        :param iterative:
        :param k_sim_malware_retrieve:
        :param md5_value:
        :return:
        """
        self.log.info("Building phylogenetic tree")
        mafft_fname = fasta_fname.split(".")[0] + ".mafft"
        tree_fname = fasta_fname.split(".")[0] + ".phy"

        self.log.info("Invoking MAFFT as sub-process")
        if iterative:
            test_file_name = fasta_fname + "_add"
            mafft_subprocess = Popen([os.environ["mafft"], "--add", test_file_name, "--reorder", fasta_fname],
                                     stdout=open(mafft_fname, "w"))
        else:
            mafft_subprocess = Popen([os.environ["mafft"], fasta_fname], stdout=open(mafft_fname, "w"))
        self.log.info("MAFFT subprocess output : {}".format(mafft_subprocess.communicate()))

        self.log.info("Invoking FastTree as sub-process")
        fasttree_subprocess = Popen([os.environ["FastTree"], "-fastest", mafft_fname], stdout=open(tree_fname, "w"))
        self.log.info("FastTree subprocess output : {}".format(fasttree_subprocess.communicate()))

        node_dict = self.get_sister_groups(tree_fname, k_sim_malware_retrieve, md5_value)
        return tree_fname, node_dict

    def sequence_alignment(self, doc2bow, doc2bow_test):
        """
        Takes as input the doc2bow and then builds a meta_cluster.
        For each of the malware's features, it then creates a binary vector representation.
        The resultant output is the sequence in a coo_matrix format and row_index of the given malware.
        :param doc2bow:
        :param doc2bow_test:
        :return:
        """
        meta_cluster_count_dict = dict()
        meta_cluster_dict = defaultdict(list)
        meta_cluster_dict.default_factory = meta_cluster_dict.__len__

        meta_cluster = self.helper.flatten_list(doc2bow.values())
        for value in meta_cluster:
            meta_cluster_dict[value]
            if value in meta_cluster_count_dict:
                meta_cluster_count_dict[value] += 1
            else:
                meta_cluster_count_dict[value] = 1

        meta_sequence = list()
        meta_cluster_dict_len = len(meta_cluster_dict.keys())
        key_list = doc2bow.keys()
        for value in doc2bow.values():
            column = list(set([meta_cluster_dict[x] for x in value]))
            meta_sequence.append(column)

        if doc2bow_test is not None:
            test_cluster = self.helper.flatten_list(doc2bow_test.values())
            test_cluster = [x for x in test_cluster if x in meta_cluster_dict]

            test_sequence = list()
            for t_value in doc2bow_test.values():
                t_column = list(set([meta_cluster_dict[t_x] for t_x in t_value if t_x in test_cluster]))
                test_sequence.append(t_column)

        sequence_list = [meta_sequence, test_sequence]
        return sequence_list, key_list, meta_cluster_dict_len, meta_cluster_count_dict

    def with_encoding(self, **kwargs):
        """
        Creates a file for MSA which will be input for the MAFFT. Uses the old method where encoding is present.
        In case of building a new MSA file from scratch then it returns MSA filename and None.
        In case of adding a sequence to already existing MSA file then it returns MSA filename and Sequence filename.
        :param kwargs:
        :return:
        """
        meta_sequence = kwargs['meta_sequence']
        fasta_file_name = kwargs['fasta_fname']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        key_list = kwargs['key_list']
        iterative = kwargs['iterative']

        if iterative:
            present_list = kwargs['present_list']
            test_sequence = kwargs['test_sequence']
            add_fasta_fname = fasta_file_name + "_add"
            add_fasta_file = open(add_fasta_fname, "w")
            for x in xrange(len(test_sequence)):
                test_list = meta_cluster_dict_len * ['0']
                for y in test_sequence[x]:
                    test_list[y] = '1'
                test_str = "".join(map(str, test_list))
                test_str = self.encoder.encode(test_str)
                print >> add_fasta_file, ">" + str(present_list[x]), "\n", test_str
            add_fasta_file.close()

        main_fasta_file = open(fasta_file_name, "w")
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * ['0']
            for y in meta_sequence[x]:
                meta_list[y] = '1'
            meta_str = "".join(map(str, meta_list))
            meta_str = self.encoder.encode(meta_str)
            print >> main_fasta_file, ">" + str(key_list[x]), "\n", meta_str
        main_fasta_file.close()

        return fasta_file_name, add_fasta_fname

    @staticmethod
    def without_encoding(**kwargs):
        """
        Creates a file for MSA which will be input for the MAFFT. It uses the new method where there is no encoding.
        In case of building a new MSA file from scratch then it returns MSA filename and None.
        In case of adding a sequence to existing MSA file then it returns MSA filename and the Sequence filename.
        :param kwargs:
        :return:
        """
        meta_cluster_count_dict = kwargs['meta_cluster_count_dict']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        meta_sequence = kwargs['meta_sequence']
        key_list = kwargs['key_list']
        fasta_file_name = kwargs['fasta_file_name']
        iterative = kwargs['iterative']

        threshold = np.mean(meta_cluster_count_dict.values())
        col_index_del = [index for index, value in enumerate(meta_cluster_count_dict.values()) if
                         value < threshold]

        if iterative:
            present_list = kwargs['present_list']
            test_sequence = kwargs['test_sequence']  # This cannot be None if iterative is True.
            add_fasta_fname = fasta_file_name + "_add"
            add_file = open(add_fasta_fname, "w")
            for x in xrange(len(test_sequence)):
                test_list = meta_cluster_dict_len * ['N']
                for y in test_sequence[x]:
                    test_list[y] = 'M'
                test_list = np.delete(test_list, col_index_del)
                print >> add_file, ">" + str(present_list[x]), "\n", "".join(map(str, test_list))
            add_file.close()
        else:
            add_fasta_fname = None

        main_fasta_file = open(fasta_file_name, "w")
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * ['N']
            for y in meta_sequence[x]:
                meta_list[y] = 'M'
            meta_list = np.delete(meta_list, col_index_del)
            print >> main_fasta_file, ">" + str(key_list[x]), "\n", "".join(map(str, meta_list))
        main_fasta_file.close()

        return fasta_file_name, add_fasta_fname

    def add_sequence(self, **kwargs):
        encoding_method = kwargs['encoding_method']
        meta_cluster_count_dict = kwargs['meta_cluster_count_dict']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        meta_sequence = kwargs['meta_sequence']
        key_list = kwargs['key_list']
        phylo_path = kwargs['phylo_path']
        iterative = kwargs['iterative']
        family = kwargs['family']
        test_sequence = kwargs['test_sequence']

        if encoding_method == 'old':
            fasta_file_name = phylo_path + "/" + str(family) + "_with_enc" + ".fasta"
            if iterative:
                present_list = kwargs['present_list']
                fasta_file_name, add_fasta_fname = self.with_encoding(meta_sequence=meta_sequence,
                                                                      fasta_fname=fasta_file_name,
                                                                      meta_cluster_dict_len=meta_cluster_dict_len,
                                                                      key_list=key_list, iterative=iterative,
                                                                      present_list=present_list,
                                                                      test_sequence=test_sequence)
            else:
                fasta_file_name, add_fasta_fname = self.with_encoding(meta_sequence=meta_sequence,
                                                                      fasta_fname=fasta_file_name,
                                                                      meta_cluster_dict_len=meta_cluster_dict_len,
                                                                      key_list=key_list, iterative=iterative,
                                                                      test_sequence=test_sequence)
        elif encoding_method == 'new':
            fasta_file_name = phylo_path + "/" + str(family) + "_wo_enc" + ".fasta"
            if iterative:
                present_list = kwargs['present_list']
                fasta_file_name, add_fasta_fname = self.without_encoding(
                    meta_cluster_count_dict=meta_cluster_count_dict,
                    meta_cluster_dict_len=meta_cluster_dict_len,
                    meta_sequence=meta_sequence,
                    key_list=key_list, fasta_file_name=fasta_file_name,
                    iterative=iterative, present_list=present_list,
                    test_sequence=test_sequence)
            else:
                fasta_file_name, add_fasta_fname = self.without_encoding(
                    meta_cluster_count_dict=meta_cluster_count_dict,
                    meta_cluster_dict_len=meta_cluster_dict_len,
                    meta_sequence=meta_sequence,
                    key_list=key_list, fasta_file_name=fasta_file_name,
                    iterative=iterative, test_sequence=test_sequence)
        else:
            self.log.error("Encoding specified is not recognized")
            fasta_file_name = None
        return fasta_file_name


class LineageAnalysis:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.helper = HelperFunction()
        self.scanner = MalwareScanner()
        self.cuckoo_queue = CuckooQueue()

        self.phylo = PhylogeneticAnalysis(self.log)

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        return remote_client, local_client, clusters_db, c2db_collection

    def retrieve_msa(self, phylo_path, family, encoding_method):
        """
        Returns the MSA path if present else returns None
        :param phylo_path:
        :param encoding_method:
        :param family:
        :return:
        """
        if encoding_method == "old":
            path = phylo_path + family + "_with_enc" + ".fasta"
        elif encoding_method == "new":
            path = phylo_path + family + "_wo_enc" + ".fasta"
        else:
            self.log.error("Encoding method not supported")
            path = None
        if os.path.isfile(path):
            return path
        else:
            return None

    def print_lineage_results(self, family_node_dict, md5_value):
        for family_name, node_dict in family_node_dict.items():
            children = node_dict['children']
            sisters = node_dict['sisters']

            self.log.info("Lineage results for malware : {} belonging to family : {}".format(md5_value, family_name))
            self.log.info("Children are : {}".format(children))
            self.log.info("Sisters are : {}".format(sisters))

    @staticmethod
    def family_list_to_dict(result_list):
        family_dict = dict()
        for result in result_list:
            family = result["avclass"]["result"]
            md5_value = result["md5"]
            family_dict[md5_value] = family
        return family_dict

    def check_status_perform_analysis(self, **kwargs):
        family_md5_dict = kwargs['family_md5_dict']
        clusters_db = kwargs['clusters_db']
        c2db_collection = kwargs['c2db_collection']
        phylo_path = kwargs['phylo_path']
        encoding_method = kwargs['encoding_method']
        k_sim_malware_retrieve = kwargs['num_sim_malware_retrieve']
        md5_value = kwargs['md5_value']

        family_node_dict = dict()

        # If there is no MSA file then it needs to be created for each family.
        for family, family_md5_status in family_md5_dict.items():
            absent_list = family_md5_status['absent']
            present_list = family_md5_status['present']

            if len(absent_list) > 1:
                present_list += absent_list[1:]
                absent_list = absent_list[0]

            # For only one value
            fasta_file_name = self.phylo.phylogenetic_analysis(clusters_db=clusters_db, c2db_collection=c2db_collection,
                                                               md5_value=absent_list[0], family=family,
                                                               phylo_path=phylo_path, iterative=False,
                                                               encoding_method=encoding_method)
            self.log.info("Created MSA using MAFFT at path : {}".format(fasta_file_name))
            tree_plot_path, node_dict = self.phylo.build_phylogeny_tree(fasta_fname=fasta_file_name,
                                                                        iterative=False,
                                                                        k_sim_malware_retrieve=k_sim_malware_retrieve,
                                                                        md5_value=md5_value)
            self.log.info("Created Phylogenetic tree at path : {}".format(tree_plot_path))

            # For the rest of the md5_values
            fasta_file_name = self.phylo.phylogenetic_analysis(clusters_db=clusters_db,
                                                               c2db_collection=c2db_collection,
                                                               present_list=present_list, family=family,
                                                               phylo_path=phylo_path, iterative=True,
                                                               encoding_method=encoding_method)
            self.log.info("Updated MSA using MAFFT generated at path : {}".format(fasta_file_name))
            tree_plot_path, node_dict = self.phylo.build_phylogeny_tree(fasta_fname=fasta_file_name, iterative=True,
                                                                        k_sim_malware_retrieve=k_sim_malware_retrieve,
                                                                        md5_value=md5_value)
            self.log.info("Phylogenetic tree updated at path : {}".format(tree_plot_path))
            family_node_dict[family] = node_dict
        return family_node_dict

    def main(self, md5_value_list, md5_path_list):
        start_time = time()
        phylo_path = self.config["environment"]["phylogenetic"]
        encoding_method = self.config["yara"]["encoding_method"]
        num_sim_malware_retrieve = self.config["yara"]["num_retrieve_malware"]
        mafft_path = self.config["environment"]["mafft"]
        fasttree_path = self.config["environment"]["fasttree"]
        os.environ["mafft"] = mafft_path
        os.environ["FastTree"] = fasttree_path

        self.helper.create_dir_if_absent(phylo_path)
        remote_client, local_client, clusters_db, c2db_collection = self.get_collection()
        status_dict = self.helper.check_if_already_scanned(md5_value_list, c2db_collection)

        for md5_value, status in status_dict.items():
            if not status:
                self.log.info("The malware is not yet encountered.\nPlease wait while analysis is done on it.")
                index = md5_value_list.index(md5_value)
                self.cuckoo_queue.main(md5_value=md5_value, md5_path=md5_path_list[index])

        result_list = self.scanner.main(list_of_keys=status_dict.keys(), keys_path=[], flag=True)

        family_md5_dict = defaultdict(list)
        for result in result_list:
            family_md5_status = defaultdict(list)
            family = result["avclass"]["result"]
            md5_value = result["md5"]
            file_status = self.retrieve_msa(phylo_path=phylo_path, encoding_method=encoding_method, family=family)
            if file_status is None:
                family_md5_status['absent'].append(md5_value)
            else:
                family_md5_status['present'].append(md5_value)
            family_md5_dict[family].append(family_md5_status)

            family_node_dict = self.check_status_perform_analysis(family_md5_dict=family_md5_dict,
                                                                  clusters_db=clusters_db,
                                                                  c2db_collection=c2db_collection,
                                                                  phylo_path=phylo_path,
                                                                  encoding_method=encoding_method,
                                                                  num_sim_malware_retrieve=num_sim_malware_retrieve,
                                                                  md5_value=md5_value)

            self.print_lineage_results(family_node_dict, md5_value)

        remote_client.close()
        local_client.close()

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    lineage = LineageAnalysis()
    lineage.main(md5_value_list=["dbc934cdc7a0530f75d6c0639c1e8100", "9144ab229902c47d43ab8c5aaf16a449"],
                 md5_path_list=[""])
