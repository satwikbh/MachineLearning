import os
import matplotlib.pyplot as plt
import urllib
import numpy as np
import matplotlib

from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient
from collections import defaultdict
from time import time
from Bio import Phylo
from subprocess import check_output
from scipy.spatial.distance import pdist, squareform

from Utils.ConfigUtil import ConfigUtil
from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from MalwareSignature.MalwareScanner import MalwareScanner
from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Cluster2DB.CuckooQueue import CuckooQueue
from HelperFunctions.Encoding import Encoding

matplotlib.use('Agg')


class PhylogeneticAnalysis:
    def __init__(self, log):
        self.log = log

        self.parser = ParsingLogic()
        self.encoder = Encoding()
        self.helper = HelperFunction()

    @staticmethod
    def remove_scanning_key(md5_value, doc2bow):
        doc2bow_test = defaultdict(list)
        vs_source = "VirusShare_" + str(md5_value)
        doc2bow_test[vs_source] = doc2bow[vs_source]
        doc2bow.pop(vs_source)
        return doc2bow_test, doc2bow

    @staticmethod
    def plot_tree(tree, output_file):
        """
        Takes the newick tree data and then plots the dendrogram out of it.
        Saved the plot at the output location.
        :param tree:
        :param output_file:
        :return:
        """
        # TODO : Highlight the node at the index position so as to know that it is the malware scanned.
        matplotlib.rc('font', size=6)
        fig = plt.figure(figsize=(10, 20), dpi=100)
        axes = fig.add_subplot(1, 1, 1)
        plt.savefig(output_file, dpi=100)
        Phylo.draw(tree, axes=axes)
        return

    def phylogenetic_analysis(self, **kwargs):
        """
        Separate this method
        :param kwargs:
        :return:
        """
        clusters_db = kwargs['clusters_db']
        c2db_collection = kwargs['c2db_collection']
        md5_value = kwargs['md5_value']
        family = kwargs['family']
        compute_cosine = kwargs['compute_cosine']
        k_value = kwargs['k_value']
        phylo_path = kwargs['phylo_path']
        iterative = kwargs['iterative']
        encoding_method = kwargs['encoding_method']

        if family in clusters_db.collection_names():
            collection = clusters_db[family]
            cursor = collection.find({"md5": {"$exists": True}})
            list_of_keys = list()
            for doc in cursor:
                list_of_keys += doc["md5"]
            list_of_docs = ["VirusShare_" + str(x) for x in list_of_keys]
            doc2bow = self.parser.parse_each_document(collection=c2db_collection, list_of_docs=list_of_docs)
            doc2bow_test, doc2bow = self.remove_scanning_key(md5_value, doc2bow)
            meta_sequence, index, key_list, meta_cluster_dict_len, meta_cluster_count_dict = self.sequence_alignment(
                doc2bow, md5_value)
            if compute_cosine:
                cosine_similar_malware = self.cosine_similar_malware(meta_sequence=meta_sequence,
                                                                     key_list=key_list,
                                                                     meta_cluster_dict_len=meta_cluster_dict_len,
                                                                     input_md5=md5_value,
                                                                     k_value=k_value)

            fasta_file_name = self.add_sequence(phylo_path=phylo_path, encoding_method=encoding_method,
                                                meta_cluster_count_dict=meta_cluster_count_dict,
                                                meta_cluster_dict_len=meta_cluster_dict_len,
                                                meta_sequence=meta_sequence, key_list=key_list,
                                                iterative=iterative, md5_value=md5_value,
                                                family=family)
        else:
            self.log.error("The inferred family is not in the Database")
            fasta_file_name = None
        return fasta_file_name

    def build_phylogeny_tree(self, phylo_path, fasta_fname):
        """
        Takes the fasta file path as input and then generates the phylogenetic tree.
        :param phylo_path:
        :param fasta_fname:
        :return:
        """
        self.log.info("Building phylogenetic tree")
        mafft_fname = fasta_fname.split(".")[0] + ".mafft"
        tree_fname = fasta_fname.split(".")[0] + ".phy"
        tree_plot_path = phylo_path + "/" + fasta_fname.split(".")[0] + ".png"

        self.log.info("Invoking MAFFT as sub-process")
        output = check_output(["mafft", "--clustalout", fasta_fname, mafft_fname])
        self.log.info("MAFFT subprocess output : {}".format(output))

        self.log.info("Invoking FastTree as sub-process")
        output = check_output(["FastTree", mafft_fname, ">", tree_fname])
        self.log.info("FastTree subprocess output : {}".format(output))

        tree = Phylo.read(tree_fname, "newick")
        self.plot_tree(tree=tree, output_file=tree_plot_path)
        self.log.info("Saving the tree plot at : {}".format(tree_plot_path))
        return tree_plot_path

    def sequence_alignment(self, doc2bow, md5_value):
        """
        Takes as input the doc2bow and then builds a meta_cluster.
        For each of the malware's features, it then creates a binary vector representation.
        The resultant output is the sequence in a coo_matrix format and row_index of the given malware.
        :param md5_value:
        :param doc2bow:
        :return:
        """
        meta_cluster_dict = defaultdict(list)
        meta_cluster_count_dict = dict()
        meta_cluster_dict.default_factory = meta_cluster_dict.__len__

        meta_cluster = self.helper.flatten_list(doc2bow.values())
        for value in meta_cluster:
            meta_cluster_dict[value]
            if value in meta_cluster_count_dict:
                meta_cluster_count_dict[value] += 1
            else:
                meta_cluster_count_dict[value] = 1

        meta_sequence = list()
        meta_cluster_dict_len = len(meta_cluster_dict.keys())
        key_list = doc2bow.keys()
        for key, value in doc2bow.items():
            column = list(set([meta_cluster_dict[x] for x in value]))
            meta_sequence.append(column)

        index = doc2bow.keys().index(md5_value)
        return meta_sequence, index, key_list, meta_cluster_dict_len, meta_cluster_count_dict

    @staticmethod
    def cosine_similar_malware(**kwargs):
        """
        :param kwargs:
        :return:
        """
        meta_sequence = kwargs['meta_sequence']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        key_list = kwargs['key_list']
        input_md5 = kwargs['input_md5']
        k_value = kwargs['k_value']

        input_vector = list()
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * [0]
            for y in meta_sequence[x]:
                meta_list[y] = 1
            input_vector.append(meta_list)
        input_matrix = np.asarray(input_vector, dtype=np.int)
        dist_matrix = 1 - pdist(input_matrix, metric="cosine")
        similarity_matrix = squareform(dist_matrix)
        value = key_list.index(input_md5)
        indices = similarity_matrix[value].argsort()[-k_value:][::-1]
        return [key_list[x] for x in indices]

    def with_encoding(self, **kwargs):
        """
        Creates a file for MSA which will be input for the MAFFT. Uses the old method where encoding is present.
        In case of building a new MSA file from scratch then it returns MSA filename and None.
        In case of adding a sequence to already existing MSA file then it returns MSA filename and the Sequence filename.
        :param kwargs:
        :return:
        """
        meta_sequence = kwargs['meta_sequence']
        fasta_file_name = kwargs['fasta_fname']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        key_list = kwargs['key_list']
        iterative = kwargs['iterative']
        md5_value = kwargs['md5_value']

        if iterative:
            test_sequence = kwargs['test_sequence']
            add_fasta_fname = fasta_file_name + "_add"
            add_fasta_file = open(add_fasta_fname, "w")
            test_list = meta_cluster_dict_len * ['0']
            for y in test_sequence:
                test_list[y] = '1'
            test_str = "".join(map(str, test_list))
            test_str = self.encoder.encode(test_str)
            print(add_fasta_file, ">" + str(md5_value), "\n", test_str)
            add_fasta_file.close()

        main_fasta_file = open(fasta_file_name, "w")
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * ['0']
            for y in meta_sequence[x]:
                meta_list[y] = '1'
            meta_str = "".join(map(str, meta_list))
            meta_str = self.encoder.encode(meta_str)
            print(main_fasta_file, ">" + str(key_list[x]), "\n", meta_str)
        main_fasta_file.close()

        return fasta_file_name, add_fasta_fname

    @staticmethod
    def without_encoding(**kwargs):
        """
        Creates a file for MSA which will be input for the MAFFT. It uses the new method where there is no encoding.
        In case of building a new MSA file from scratch then it returns MSA filename and None.
        In case of adding a sequence to already existing MSA file then it returns MSA filename and the Sequence filename.
        :param kwargs:
        :return:
        """
        meta_cluster_count_dict = kwargs['meta_cluster_count_dict']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        meta_sequence = kwargs['meta_sequence']
        key_list = kwargs['key_list']
        fasta_file_name = kwargs['fasta_file_name']
        iterative = kwargs['iterative']
        md5_value = kwargs['md5_value']

        threshold = np.mean(meta_cluster_count_dict.values())
        col_index_del = [index for index, value in enumerate(meta_cluster_count_dict.values()) if
                         value < threshold]

        if iterative:
            test_sequence = kwargs['test_sequence']
            add_fasta_fname = fasta_file_name + "_add"
            add_file = open(add_fasta_fname, "w")
            test_list = meta_cluster_dict_len * ['N']
            for y in test_sequence:
                test_list[y] = 'M'
            test_list = np.delete(test_list, col_index_del)
            print(add_file, ">" + str(md5_value), "\n", "".join(map(str, test_list)))
            add_file.close()

        main_fasta_file = open(fasta_file_name, "w")
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * ['N']
            for y in meta_sequence[x]:
                meta_list[y] = 'M'
            meta_list = np.delete(meta_list, col_index_del)
            print(main_fasta_file, ">" + str(key_list[x]), "\n", "".join(map(str, meta_list)))
        main_fasta_file.close()

        return fasta_file_name, add_fasta_fname

    def add_sequence(self, **kwargs):
        encoding_method = kwargs['encoding_method']
        meta_cluster_count_dict = kwargs['meta_cluster_count_dict']
        meta_cluster_dict_len = kwargs['meta_cluster_dict_len']
        meta_sequence = kwargs['meta_sequence']
        key_list = kwargs['key_list']
        phylo_path = kwargs['phylo_path']
        iterative = kwargs['iterative']
        family = kwargs['family']
        md5_value = kwargs['md5_value']

        if encoding_method == 'old':
            fasta_file_name = phylo_path + "/" + str(family) + "_with_enc" + ".fasta"
            fasta_file_name, add_fasta_fname = self.with_encoding(meta_sequence=meta_sequence,
                                                                  fasta_fname=fasta_file_name,
                                                                  meta_cluster_dict_len=meta_cluster_dict_len,
                                                                  key_list=key_list, iterative=iterative,
                                                                  md5_value=md5_value)
        elif encoding_method == 'new':
            fasta_file_name = phylo_path + "/" + str(family) + "_wo_enc" + ".fasta"
            fasta_file_name, add_fasta_fname = self.without_encoding(meta_cluster_count_dict=meta_cluster_count_dict,
                                                                     meta_cluster_dict_len=meta_cluster_dict_len,
                                                                     meta_sequence=meta_sequence,
                                                                     key_list=key_list, fasta_file_name=fasta_file_name,
                                                                     iterative=False, md5_value=md5_value)
        else:
            self.log.error("Encoding specified is not recognized")
            fasta_file_name = None
        return fasta_file_name


class LineageAnalysis:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.helper = HelperFunction()
        self.scanner = MalwareScanner()
        self.cuckoo_queue = CuckooQueue()

        self.phylo = PhylogeneticAnalysis(self.log)

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        return remote_client, local_client, clusters_db, c2db_collection

    @staticmethod
    def check_if_aready_scanned(md5_value, c2db_collection):
        key = "VirusShare_" + md5_value
        cursor = c2db_collection.find({"key": key})
        if cursor.count() > 0:
            return True
        else:
            return False

    def retrieve_msa(self, phylo_path, family, encoding_method):
        """
        Returns the MSA path if present else returns None
        :param phylo_path:
        :param family:
        :return:
        """
        if encoding_method == "old":
            path = phylo_path + family + "_with_enc" + ".fasta"
        elif encoding_method == "new":
            path = phylo_path + family + "_wo_enc" + ".fasta"
        else:
            self.log.error("Encoding method not supported")
            path = None
        if os.path.isfile(path):
            return path
        else:
            return None

    def main(self, md5_value, md5_path):
        start_time = time()
        phylo_path = self.config["environment"]["phylogenetic"]
        encoding_method = self.config["yara"]["encoding_method"]
        num_sim_malware_retrieve = self.config["yara"]["num_retrieve_malware"]
        mafft_path = self.config["environment"]["mafft"]
        os.environ["mafft"] = mafft_path

        compute_cosine = self.config["yara"]["compute_cosine"]

        self.helper.create_dir_if_absent(phylo_path)
        remote_client, local_client, clusters_db, c2db_collection = self.get_collection()
        status = self.check_if_aready_scanned(md5_value, c2db_collection)

        if not status:
            self.log.info("The malware is not yet encountered.\nPlease wait while analysis is done on it.")
            self.cuckoo_queue.main(md5_value=md5_value, md5_path=md5_path)

        result = self.scanner.main(list_of_keys=[md5_value])
        family = result[0]["family"]
        msa_file_status = self.retrieve_msa(phylo_path, family, encoding_method)
        md5_value = "VirusShare_" + md5_value

        if msa_file_status is None:
            fasta_file_name = self.phylo.phylogenetic_analysis(clusters_db=clusters_db, c2db_collection=c2db_collection,
                                                               md5_value=md5_value, family=family,
                                                               compute_cosine=compute_cosine,
                                                               k_value=num_sim_malware_retrieve,
                                                               phylo_path=phylo_path, iterative=False,
                                                               encoding_method=encoding_method)
            self.log.info("Created MSA using MAFFT at path : {}".format(fasta_file_name))
            tree_plot_path = self.phylo.build_phylogeny_tree(phylo_path, fasta_file_name)
            self.log.info("Created Phylogenetic tree at path : {}".format(tree_plot_path))
        else:
            fasta_file_name = self.phylo.phylogenetic_analysis(clusters_db=clusters_db, c2db_collection=c2db_collection,
                                                               md5_value=md5_value, family=family,
                                                               compute_cosine=compute_cosine,
                                                               k_value=num_sim_malware_retrieve,
                                                               phylo_path=phylo_path, iterative=True,
                                                               encoding_method=encoding_method)
            self.log.info("Updated MSA using MAFFT generated at path : {}".format(fasta_file_name))
            tree_plot_path = self.phylo.build_phylogeny_tree(phylo_path, fasta_file_name)
            self.log.info("Phylogenetic tree updated at path : {}".format(tree_plot_path))

        remote_client.close()
        local_client.close()

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    lineage = LineageAnalysis()
    lineage.main(md5_value="", md5_path="")
