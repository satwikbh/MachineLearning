import os
import urllib
import matplotlib
import json

from collections import defaultdict
from time import time

from PhylogeneticAnalysis import PhylogeneticAnalysis
from Utils.ConfigUtil import ConfigUtil
from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from MalwareSignature.MalwareScanner import MalwareScanner
from HelperFunctions.HelperFunction import HelperFunction
from Cluster2DB.CuckooQueue import CuckooQueue

matplotlib.use('Agg')


class LineageAnalysis:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.helper = HelperFunction()
        self.scanner = MalwareScanner()
        self.cuckoo_queue = CuckooQueue()

        self.phylo = PhylogeneticAnalysis(self.log)

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                          is_auth_enabled=is_auth_enabled,
                                          username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = client[clusters_db_name]

        return client, clusters_db, c2db_collection

    def retrieve_msa(self, phylo_path, family, encoding_method):
        """
        If there is a fasta file present for the family then returns the path else returns none.
        :param phylo_path: The path where the fasta file needs to be stored.
        :param encoding_method: If old then 3 bit sequence is considered. If new no sequencing is considered.
        :param family: The family to which the malware belong to.
        :return:
        """
        if encoding_method == "old":
            path = phylo_path + family + "_with_enc" + ".fasta"
        elif encoding_method == "new":
            path = phylo_path + family + "_wo_enc" + ".fasta"
        else:
            self.log.error("Encoding method not supported")
            path = None
        if os.path.isfile(path):
            return path
        else:
            return None

    def print_lineage_results(self, family_node_dict):
        for family_name, meta_node_dict in family_node_dict.items():
            for md5_value, node_dict in meta_node_dict.items():
                children = node_dict['children']
                sisters = node_dict['sisters']

                self.log.info(
                    "Lineage results for malware : {} belonging to family : {}".format(md5_value, family_name))
                self.log.info("Children are : {}".format(children))
                self.log.info("Sisters are : {}".format(sisters))

    @staticmethod
    def family_list_to_dict(result_list):
        family_dict = dict()
        for result in result_list:
            family = result["avclass"]["result"]
            md5_value = result["md5"]
            family_dict[md5_value] = family
        return family_dict

    def check_status_perform_analysis(self, **kwargs):
        """
        Checks the status for the malware and performs phylogenetic analysis if not present.
        :param kwargs:
        :return:
        """
        family_md5_dict = kwargs['family_md5_dict']
        clusters_db = kwargs['clusters_db']
        c2db_collection = kwargs['c2db_collection']
        phylo_path = kwargs['phylo_path']
        encoding_method = kwargs['encoding_method']
        k = kwargs['num_sim_malware_retrieve']
        md5_list = kwargs['md5_list']
        freq_individual_pool_path = kwargs['freq_individual_pool_path']

        family_node_dict = dict()

        for family, family_md5_status_list in family_md5_dict.items():
            for family_md5_status in family_md5_status_list:
                # The keys will either be present in absent key or present key.
                absent_list = family_md5_status['absent']
                present_list = family_md5_status['present']

                if len(absent_list) > 0:
                    target_list = absent_list
                    iterative = False
                elif len(present_list) > 0:
                    target_list = present_list
                    iterative = True
                else:
                    raise Exception("Error : Keys should be present in either of absent or present list.")

                if encoding_method == 'new':
                    fasta_file_name = phylo_path + "/" + str(family) + "_wo_enc" + ".fasta"
                elif encoding_method == 'old':
                    fasta_file_name = phylo_path + "/" + str(family) + "_with_enc" + ".fasta"
                else:
                    fasta_file_name = None

                if self.helper.is_file_present(fasta_file_name):
                    self.log.info("Updated MSA using MAFFT generated at path : {}".format(fasta_file_name))
                    tree_plot_path, meta_node_dict = self.phylo.build_phylogeny_tree(fasta_fname=fasta_file_name,
                                                                                     iterative=True,
                                                                                     k_sim_malware_retrieve=k,
                                                                                     md5_list=md5_list)
                    self.log.info("Phylogenetic tree updated at path : {}".format(tree_plot_path))
                else:
                    fasta_file_name = self.phylo.phylogenetic_analysis(clusters_db=clusters_db,
                                                                       c2db_collection=c2db_collection,
                                                                       target_list=target_list,
                                                                       family=family,
                                                                       phylo_path=phylo_path,
                                                                       iterative=iterative,
                                                                       encoding_method=encoding_method,
                                                                       freq_individual_pool_path=freq_individual_pool_path)
                    self.log.info("Created MSA for MAFFT at path : {}".format(fasta_file_name))
                    tree_plot_path, meta_node_dict = self.phylo.build_phylogeny_tree(fasta_fname=fasta_file_name,
                                                                                     iterative=False,
                                                                                     k_sim_malware_retrieve=k,
                                                                                     md5_list=md5_list)
                    self.log.info("Created Phylogenetic tree at path : {}".format(tree_plot_path))

                family_node_dict[family] = meta_node_dict
        return family_node_dict

    def get_result_list(self, entire_data, c2db_collection, md5_value_list, md5_path_list, classified_families_path):
        """
        Will return the result list which contains the md5 of all malware executables which were scanned.
        :param entire_data: flag which decides if phylogeny needs to be done on entire dataset.
        :param c2db_collection: the cluster2db collection
        :param md5_value_list: list of md5.
        :param md5_path_list: list of the path of the executables.
        :param classified_families_path: path which contains the classified_families json file.
        :return:
        """
        if entire_data:
            classified_families = json.load(open(classified_families_path + "/" + "classified_families.json"))
            md5_value_list = self.helper.flatten_list(classified_families.values())
        status_dict = self.helper.check_if_already_scanned(md5_value_list=md5_value_list,
                                                           c2db_collection=c2db_collection,
                                                           chunk=2000)
        for md5_value, status in status_dict.items():
            if not status:
                self.log.info("The malware is not yet encountered.\nPlease wait while analysis is done on it.")
                index = md5_value_list.index(md5_value)
                self.cuckoo_queue.main(md5_value=md5_value, md5_path=md5_path_list[index])

        result_list = self.scanner.main(list_of_keys=status_dict.keys(), keys_path=md5_path_list, flag=True)
        return result_list

    def check_fasta_file_present(self, family, md5_list, phylo_path, encoding_method):
        """
        Checks if the fasta file for the malware family is present or not.
        If present, the list of malware belonging to that family are added to present key.
        Else added to the absent key.
        :param family: Malware family
        :param md5_list: For above family, md5_list.
        :param phylo_path: Path of the fasta file.
        :param encoding_method: New or Old encoding. Old uses sequencing and New uses None.
        :return:
        """
        family_md5_status = defaultdict(list)
        file_status = self.retrieve_msa(phylo_path=phylo_path, encoding_method=encoding_method, family=family)
        if file_status is None:
            family_md5_status['absent'] += md5_list
        else:
            family_md5_status['present'] += md5_list
        return family, family_md5_status

    def main(self, md5_value_list, md5_path_list, entire_data=False):
        start_time = time()

        phylo_path = self.config["environment"]["phylogenetic"]
        encoding_method = self.config["yara"]["encoding_method"]
        num_sim_malware_retrieve = self.config["yara"]["num_retrieve_malware"]
        mafft_path = self.config["environment"]["mafft"]
        fasttree_path = self.config["environment"]["fasttree"]
        classified_families_path = self.config["data"]["classified_families_path"]
        freq_individual_pool_path = self.config["data"]["freq_individual_feature_pool_path"]

        os.environ["mafft"] = mafft_path
        os.environ["FastTree"] = fasttree_path

        self.helper.create_dir_if_absent(phylo_path)

        client, clusters_db, c2db_collection = self.get_collection()
        result_list = self.get_result_list(entire_data, c2db_collection,
                                           md5_value_list, md5_path_list, classified_families_path)

        family_md5_mapping = defaultdict(list)
        for result in result_list:
            family = result["avclass"]["result"]
            md5_value = result["md5"]
            family_md5_mapping[family].append(md5_value)

        family_md5_dict = defaultdict(list)
        for family, md5_list in family_md5_mapping.items():
            family, family_md5_status = self.check_fasta_file_present(family=family,
                                                                      md5_list=md5_list,
                                                                      phylo_path=phylo_path,
                                                                      encoding_method=encoding_method)
            family_md5_dict[family].append(family_md5_status)
            family_node_dict = self.check_status_perform_analysis(family_md5_dict=family_md5_dict,
                                                                  clusters_db=clusters_db,
                                                                  c2db_collection=c2db_collection,
                                                                  phylo_path=phylo_path,
                                                                  encoding_method=encoding_method,
                                                                  num_sim_malware_retrieve=num_sim_malware_retrieve,
                                                                  md5_list=md5_list,
                                                                  freq_individual_pool_path=freq_individual_pool_path)
            self.print_lineage_results(family_node_dict=family_node_dict)
        client.close()

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    lineage = LineageAnalysis()
    md5_list = json.load(open(""))
    lineage.main(entire_data=False,
                 md5_value_list=md5_list,
                 md5_path_list=[""] * len(md5_list))
