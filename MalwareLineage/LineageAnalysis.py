import os
import matplotlib.pyplot as plt
import urllib
import numpy as np
import matplotlib

from sshtunnel import SSHTunnelForwarder
from pymongo import MongoClient
from collections import defaultdict
from time import time
from Bio import Phylo
from subprocess import check_output

from Utils.ConfigUtil import ConfigUtil
from Utils.LoggerUtil import LoggerUtil
from Utils.DBUtils import DBUtils
from MalwareSignature.MalwareScanner import MalwareScanner
from HelperFunctions.HelperFunction import HelperFunction
from PrepareData.ParsingLogic import ParsingLogic
from Cluster2DB.CuckooQueue import CuckooQueue
from HelperFunctions.Encoding import Encoding

matplotlib.use('Agg')


class LineageAnalysis:
    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.scanner = MalwareScanner()
        self.helper = HelperFunction()
        self.parser = ParsingLogic()
        self.cuckoo_queue = CuckooQueue()
        self.encoder = Encoding()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        return remote_client, local_client, clusters_db, c2db_collection

    @staticmethod
    def plot_tree(tree, output_file, index):
        """
        Takes the newick tree data and then plots the dendrogram out of it.
        Saved the plot at the output location.
        :param tree:
        :param output_file:
        :param index:
        :return:
        """
        # TODO : Highlight the node at the index position so as to know that it is the malware scanned.
        matplotlib.rc('font', size=6)
        fig = plt.figure(figsize=(10, 20), dpi=100)
        axes = fig.add_subplot(1, 1, 1)
        plt.savefig(output_file, dpi=100)
        Phylo.draw(tree, axes=axes)
        return

    def build_phylogeny_tree(self, phylo_path, fasta_fname, index):
        """
        Takes the fasta file path as input and then generates the phylogenetic tree.
        :param phylo_path:
        :param fasta_fname:
        :param index:
        :return:
        """
        self.log.info("Building phylogenetic tree")
        mafft_fname = fasta_fname.split(".")[0] + ".mafft"
        tree_fname = fasta_fname.split(".")[0] + ".phy"
        tree_plot_path = phylo_path + "/" + fasta_fname.split(".")[0] + ".png"

        self.log.info("Invoking MAFFT as sub-process")
        output = check_output(["mafft", "--clustalout", fasta_fname, mafft_fname])
        self.log.info("MAFFT subprocess output : {}".format(output))

        self.log.info("Invoking FastTree as sub-process")
        output = check_output(["FastTree", mafft_fname, ">", tree_fname])
        self.log.info("FastTree subprocess output : {}".format(output))

        tree = Phylo.read(tree_fname, "newick")
        self.plot_tree(tree=tree, output_file=tree_plot_path, index=index)
        self.log.info("Saving the tree plot at : {}".format(tree_plot_path))

    def sequence_alignment(self, doc2bow, md5_value):
        """
        Takes as input the doc2bow and then builds a meta_cluster.
        For each of the malware's features, it then creates a binary vector representation.
        The resultant output is the sequence in a coo_matrix format and row_index of the given malware.
        :param md5_value:
        :param doc2bow:
        :return:
        """
        md5_value = "VirusShare_" + md5_value
        meta_cluster_dict = defaultdict(list)
        meta_cluster_count_dict = dict()
        meta_cluster_dict.default_factory = meta_cluster_dict.__len__

        meta_cluster = self.helper.flatten_list(doc2bow.values())
        for value in meta_cluster:
            meta_cluster_dict[value]
            if value in meta_cluster_count_dict:
                meta_cluster_count_dict[value] += 1
            else:
                meta_cluster_count_dict[value] = 1

        meta_sequence = list()
        meta_cluster_dict_len = len(meta_cluster_dict.keys())
        key_list = doc2bow.keys()
        for key, value in doc2bow.items():
            if key == md5_value:
                index = len(meta_sequence)
            column = [meta_cluster_dict[x] for x in value]
            meta_sequence.append(column)

        return meta_sequence, index, key_list, meta_cluster_dict_len, meta_cluster_count_dict

    def with_encoding(self, meta_sequence, fasta_fname, meta_cluster_dict_len, key_list):
        f = open(fasta_fname, "w")
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * ['0']
            for y in meta_sequence[x]:
                meta_list[y] = '1'
            meta_str = "".join(map(str, meta_list))
            meta_str = self.encoder.encode(meta_str)
            print(f, ">" + str(key_list[x]), "\n", meta_str)
        f.close()

    @staticmethod
    def without_encoding(meta_cluster_count_dict, fasta_fname, meta_sequence, meta_cluster_dict_len,
                         key_list):
        threshold = np.mean(meta_cluster_count_dict.values())
        col_index_del = [index for index, value in enumerate(meta_cluster_count_dict.values()) if
                         value < threshold]

        f = open(fasta_fname, "w")
        for x in xrange(len(meta_sequence)):
            meta_list = meta_cluster_dict_len * ['N']
            for y in meta_sequence[x]:
                meta_list[y] = 'M'
            meta_list = np.delete(meta_list, col_index_del)
            print(f, ">" + str(key_list[x]), "\n", "".join(map(str, meta_list)))
        f.close()

    def phylogenetic_analysis(self, md5_value, clusters_db, c2db_collection, phylo_path, encoding_method):
        result = self.scanner.main(list_of_keys=[md5_value])
        family = result[0]["family"]
        if family in clusters_db.collection_names():
            collection = clusters_db[family]
            cursor = collection.find({"md5": {"$exists": True}})
            list_of_keys = list()
            for doc in cursor:
                list_of_keys += doc["md5"]
            list_of_docs = ["VirusShare_" + str(x) for x in list_of_keys]
            doc2bow = self.parser.parse_each_document(collection=c2db_collection, list_of_docs=list_of_docs)
            meta_sequence, index, key_list, meta_cluster_dict_len, meta_cluster_count_dict = self.sequence_alignment(
                doc2bow, md5_value)
            if encoding_method == "new":
                # New method
                fasta_fname = phylo_path + "/" + str(md5_value) + "_wo_enc" + ".fasta"
                self.without_encoding(meta_cluster_count_dict=meta_cluster_count_dict,
                                      meta_cluster_dict_len=meta_cluster_dict_len,
                                      meta_sequence=meta_sequence,
                                      key_list=key_list,
                                      fasta_fname=fasta_fname)
            elif encoding_method == "old":
                # Old method
                fasta_fname = phylo_path + "/" + str(md5_value) + "_with_enc" + ".fasta"
                self.with_encoding(meta_sequence=meta_sequence,
                                   fasta_fname=fasta_fname,
                                   meta_cluster_dict_len=meta_cluster_dict_len,
                                   key_list=key_list)
            else:
                self.log.error("Encoding specified is not recognized")
                fasta_fname = None
            assert fasta_fname is not None
            self.build_phylogeny_tree(phylo_path, fasta_fname, index)
        else:
            self.log.error("The inferred family is not in the Database")

    @staticmethod
    def check_if_aready_scanned(md5_value, c2db_collection):
        key = "VirusShare_" + md5_value
        cursor = c2db_collection.find({"key": key})
        if cursor.count() > 0:
            return True
        else:
            return False

    def main(self, md5_value, md5_path):
        start_time = time()
        phylo_path = self.config["environment"]["phylogenetic"]
        encoding_method = self.config[""][""]
        mafft_path = self.config["environment"]["mafft"]
        os.environ["mafft"] = mafft_path
        self.helper.create_dir_if_absent(phylo_path)
        remote_client, local_client, clusters_db, c2db_collection = self.get_collection()
        status = self.check_if_aready_scanned(md5_value, c2db_collection)
        if status:
            self.phylogenetic_analysis(md5_value, clusters_db, c2db_collection, phylo_path,
                                       encoding_method=encoding_method)
        else:
            self.log.info("The malware is not yet encountered.\nPlease wait while analysis is done on it.")
            self.cuckoo_queue.main(md5_value=md5_value, md5_path=md5_path)
        remote_client.close()
        local_client.close()

        self.log.info("Total time taken : {}".format(time() - start_time))


if __name__ == '__main__':
    phylogeny = LineageAnalysis()
    phylogeny.main(md5_value="", md5_path="")
