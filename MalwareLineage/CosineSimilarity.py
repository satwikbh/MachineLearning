import urllib
import json
import math
import re

from collections import Counter
from pymongo import MongoClient
from sshtunnel import SSHTunnelForwarder
from time import time
from elasticsearch_dsl import Search, Q

from HelperFunctions.HelperFunction import HelperFunction
from Cluster2DB.CuckooQueue import CuckooQueue
from PrepareData.ParsingLogic import ParsingLogic
from Utils.LoggerUtil import LoggerUtil
from Utils.ConfigUtil import ConfigUtil
from Utils.DBUtils import DBUtils
from Utils.ElasticUtil import ElasticUtil


class CosineSimilarity:
    """
    This class is to be used in case of fast retrieval.
    1. It takes the malware and checks if it is present in DB.
        a. If absent send to kafka queue for analysis.
        b. If present, then get the malware features
    2. The malware is scanned by the signature
        a. If it is detected then get the family name and search in the corresponding ES index.
        b. Else, From the retrieved features, check across all clusters and retrieve most similar docs.
    3. There are two similarity measures
        a. For current malware's feature list, get tf-idf score for all clusters and return most similar ones.
        b. From the tf-idf keys, compute pairwise cosine similarity and then return most similar docs.
    """

    def __init__(self):
        self.log = LoggerUtil(self.__class__.__name__).get()
        self.config = ConfigUtil.get_config_instance()
        self.db_utils = DBUtils()
        self.helper = HelperFunction()
        self.cuckoo_queue = CuckooQueue()
        self.parser = ParsingLogic()
        self.es_util = ElasticUtil()

    def get_collection(self):
        username = self.config['environment']['mongo']['username']
        pwd = self.config['environment']['mongo']['password']
        password = urllib.quote(pwd)
        address = self.config['environment']['mongo']['address']
        port = self.config['environment']['mongo']['port']
        auth_db = self.config['environment']['mongo']['auth_db']
        is_auth_enabled = self.config['environment']['mongo']['is_auth_enabled']

        server = SSHTunnelForwarder("10.2.40.13", ssh_username="satwik", ssh_password="aith0561",
                                    remote_bind_address=('127.0.0.1', 27017))
        server.start()
        remote_client = MongoClient('127.0.0.1', server.local_bind_port)

        local_client = self.db_utils.get_client(address=address, port=port, auth_db=auth_db,
                                                is_auth_enabled=is_auth_enabled,
                                                username=username, password=password)
        db_name = self.config['environment']['mongo']['db_name']
        cuckoo_db = local_client[db_name]

        c2db_collection_name = self.config['environment']['mongo']['c2db_collection_name']
        c2db_collection = cuckoo_db[c2db_collection_name]

        clusters_db_name = self.config['environment']['mongo']['clusters_db_name']
        clusters_db = remote_client[clusters_db_name]

        return remote_client, local_client, clusters_db, c2db_collection

    def get_es_connection(self):
        host = self.config['elasticsearch']['host']
        port = self.config['elasticsearch']['port']
        es_client = self.es_util.get_es_client(host=host, port=port)
        return es_client

    def return_es_docs(self, feature_list, k_malware_retrieve, es_client):
        """
        Takes the feature list and gets the top "k" similar docs from Elastic Search.
        :param feature_list:
        :param k_malware_retrieve:
        :param es_client:
        :return:
        """
        must_list = list()
        similar_keys = list()

        search = Search(using=es_client)
        search = search.index('clusters')
        search.update_from_dict({"size": k_malware_retrieve})

        for feature in feature_list:
            must_list.append(feature)

        query = " ".join(must_list)
        search.query = Q('query_string', default_field='feature_pool', query=query)
        search.source(fields=['malware_source'])
        es_query_str = json.dumps(search.query.to_dict())
        self.log.info("ES Query : {}".format(es_query_str))
        response = search.execute()
        self.log.info("Response status : {}".format(response.success()))
        num_hits = response.hits.total
        self.log.info("Total number of docs retrieved : {}".format(num_hits))

        for hits in response:
            similar_keys.append(hits.malware_source)

        return similar_keys

    @staticmethod
    def get_cosine(vec1, vec2):
        intersection = set(vec1.keys()) & set(vec2.keys())
        numerator = sum([vec1[x] * vec2[x] for x in intersection])

        sum1 = sum([vec1[x] ** 2 for x in vec1.keys()])
        sum2 = sum([vec2[x] ** 2 for x in vec2.keys()])
        denominator = math.sqrt(sum1) * math.sqrt(sum2)

        if not denominator:
            return 0.0
        else:
            return float(numerator) / denominator

    @staticmethod
    def text_to_vector(words):
        return Counter(words)

    def cosine_similar_docs(self, target_value, similar_keys, c2db_collection):
        cosine_val_dict = dict()
        vec_i = self.text_to_vector(target_value)
        doc2bow = self.parser.parse_each_document(list_of_docs=similar_keys, collection=c2db_collection)
        for key, value in doc2bow.items():
            vec_j = self.text_to_vector(value)
            cosine_score = self.get_cosine(vec1=vec_i, vec2=vec_j)
            cosine_val_dict[key] = cosine_score
        return cosine_val_dict

    def get_similar(self, list_of_keys, c2db_collection, k_malware_retrieve, es_client, cosine_buffer):
        es_similar_dict = dict()
        cosine_similar_dict = dict()
        list_of_docs = self.helper.convert_to_vs_keys(list_of_keys)
        doc2bow = self.parser.parse_each_document(list_of_docs=list_of_docs, collection=c2db_collection)
        for key, value in doc2bow.items():
            similar_keys = self.return_es_docs(feature_list=value,
                                               k_malware_retrieve=k_malware_retrieve + cosine_buffer,
                                               es_client=es_client)
            es_similar_dict[key] = similar_keys
            cosine_similar_dict[key] = self.cosine_similar_docs(similar_keys=similar_keys,
                                                                target_value=value,
                                                                c2db_collection=c2db_collection)
        return es_similar_dict, cosine_similar_dict

    def main(self, md5_value_list, md5_path_list):
        start_time = time()
        k_malware_retrieve = self.config["yara"]["num_retrieve_malware"]
        cosine_buffer = self.config["yara"]["cosine_buffer"]
        remote_client, local_client, clusters_db, c2db_collection = self.get_collection()
        es_client = self.get_es_connection()
        status_dict = self.helper.check_if_already_scanned(md5_value_list, c2db_collection, chunk=2000)
        for md5_value, status in status_dict.items():
            if not status:
                self.log.info("The malware is not yet encountered.\nPlease wait while analysis is done on it.")
                index = md5_value_list.index(md5_value)
                self.cuckoo_queue.main(md5_value=md5_value, md5_path=md5_path_list[index])
        es_similar_dict, cosine_similar_dict = self.get_similar(list_of_keys=status_dict.keys(),
                                                                c2db_collection=c2db_collection,
                                                                k_malware_retrieve=k_malware_retrieve,
                                                                es_client=es_client, cosine_buffer=cosine_buffer)
        es_similar_str = json.dumps(es_similar_dict)
        cosine_similar_str = json.dumps(cosine_similar_dict)
        self.log.info("Total time taken : {}".format(time() - start_time))
        return es_similar_str, cosine_similar_str


if __name__ == '__main__':
    cosine_sim = CosineSimilarity()
    cosine_sim.main(md5_value_list=[], md5_path_list=[])
